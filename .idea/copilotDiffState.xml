<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/components/NoteCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/components/NoteCard.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo.components&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;@Composable&#10;fun NoteCard(note: Note, onNoteClick: (Note) -&gt; Unit) {&#10;    val dateFormatter = remember {&#10;        SimpleDateFormat(&quot;dd MMM yyyy, HH:mm&quot;, Locale.getDefault())&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .padding(8.dp)&#10;            .fillMaxWidth()&#10;            .clickable { onNoteClick(note) },&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(16.dp)&#10;                .fillMaxWidth()&#10;                .clickable { onNoteClick(note) }, // &lt;-- Hace toda el área de la nota clickeable&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            // Mostrar título solo si existe&#10;            if (!note.title.isNullOrEmpty() &amp;&amp; note.title != &quot;Nota sin título&quot;) {&#10;                Text(&#10;                    text = note.title,&#10;                    style = MaterialTheme.typography.titleLarge,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;&#10;            // Contenido con soporte Markdown condicional&#10;            if (note.isMarkdownEnabled) {&#10;                val isDark = isSystemInDarkTheme()&#10;                MarkdownText(&#10;                    markdown = note.content.takeIf { it.length &lt;= 120 }&#10;                        ?: &quot;${note.content.take(120)}...&quot;,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        color = if (isDark) Color.White else MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                )&#10;            } else {&#10;                Text(&#10;                    text = note.content.takeIf { it.length &lt;= 120 }&#10;                        ?: &quot;${note.content.take(120)}...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    maxLines = 4,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;&#10;            // Fecha de modificación&#10;            Text(&#10;                text = &quot;Editado: ${dateFormatter.format(Date(note.timestamp))}&quot;,&#10;                style = MaterialTheme.typography.labelSmall.copy(&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                ),&#10;                modifier = Modifier.align(Alignment.End)&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo.components&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;@Composable&#10;fun NoteCard(note: Note, onNoteClick: (Note) -&gt; Unit) {&#10;    val dateFormatter = remember {&#10;        SimpleDateFormat(&quot;dd MMM yyyy, HH:mm&quot;, Locale.getDefault())&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .padding(8.dp)&#10;            .fillMaxWidth()&#10;            .clickable { onNoteClick(note) },&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(16.dp)&#10;                .fillMaxWidth(), // Eliminar .clickable aquí&#10;            verticalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            // Mostrar título solo si existe&#10;            if (!note.title.isNullOrEmpty() &amp;&amp; note.title != &quot;Nota sin título&quot;) {&#10;                Text(&#10;                    text = note.title,&#10;                    style = MaterialTheme.typography.titleLarge,&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;&#10;            // Contenido con soporte Markdown condicional&#10;            if (note.isMarkdownEnabled) {&#10;                val isDark = isSystemInDarkTheme()&#10;                MarkdownText(&#10;                    markdown = note.content.takeIf { it.length &lt;= 120 }&#10;                        ?: &quot;${note.content.take(120)}...&quot;,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        color = if (isDark) Color.White else MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                )&#10;            } else {&#10;                Text(&#10;                    text = note.content.takeIf { it.length &lt;= 120 }&#10;                        ?: &quot;${note.content.take(120)}...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    maxLines = 4,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;            }&#10;&#10;            // Fecha de modificación&#10;            Text(&#10;                text = &quot;Editado: ${dateFormatter.format(Date(note.timestamp))}&quot;,&#10;                style = MaterialTheme.typography.labelSmall.copy(&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                ),&#10;                modifier = Modifier.align(Alignment.End)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/navigation/Navigation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/navigation/Navigation.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo.navigation&#10;&#10;import androidx.compose.animation.AnimatedContentTransitionScope&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.runtime.Composable&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.*&#10;import androidx.navigation.navArgument&#10;import com.valdo.notasinteligentesvaldo.screens.NoteDetailScreen&#10;import com.valdo.notasinteligentesvaldo.screens.NoteFormScreen&#10;import com.valdo.notasinteligentesvaldo.screens.NotesScreen&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;&#10;// Define duraciones de animación&#10;private const val NAV_ANIM_DURATION = 300 // Reducido para menos parpadeo&#10;&#10;@Composable&#10;fun AppNavigation(&#10;    viewModel: NoteViewModel,&#10;) {&#10;    val navController = rememberNavController()&#10;&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = &quot;notes?filter=all&quot; // Ruta inicial con filtro específico&#10;    ) {&#10;&#10;        // --- Pantalla de Notas (Lista) ---&#10;        composable(&#10;            route = &quot;notes?filter={filterType}&quot;,&#10;            arguments = listOf(navArgument(&quot;filterType&quot;) {&#10;                type = NavType.StringType&#10;                defaultValue = &quot;all&quot;&#10;                nullable = false&#10;            })&#10;        ) { backStackEntry -&gt;&#10;            val filterType = backStackEntry.arguments?.getString(&quot;filterType&quot;) ?: &quot;all&quot;&#10;            NotesScreen(&#10;                viewModel = viewModel,&#10;                navController = navController,&#10;                filterType = filterType,&#10;                onAddNote = { navController.navigate(&quot;addNote&quot;) }&#10;            )&#10;        }&#10;&#10;        // --- Pantalla de Añadir/Editar Nota (Formulario) ---&#10;        composable(&#10;            route = &quot;addNote&quot;,&#10;            enterTransition = {&#10;                fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            exitTransition = {&#10;                fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;        ) {&#10;            NoteFormScreen(&#10;                onNoteSaved = { newNote -&gt;&#10;                    viewModel.insertNote(newNote)&#10;                    navController.popBackStack()&#10;                },&#10;                onBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // --- Pantalla de Detalle de Nota ---&#10;        composable(&#10;            route = &quot;noteDetail/{noteId}&quot;,&#10;            arguments = listOf(navArgument(&quot;noteId&quot;) {&#10;                type = NavType.IntType&#10;            }),&#10;            enterTransition = {&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            exitTransition = {&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popEnterTransition = {&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popExitTransition = {&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;        ) { backStackEntry -&gt;&#10;            val noteId = backStackEntry.arguments?.getInt(&quot;noteId&quot;)&#10;            if (noteId != null) {&#10;                NoteDetailScreen(&#10;                    noteId = noteId,&#10;                    viewModel = viewModel,&#10;                    onBack = { navController.popBackStack() }&#10;                )&#10;            } else {&#10;                navController.popBackStack()&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo.navigation&#10;&#10;import androidx.compose.animation.AnimatedContentTransitionScope&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.runtime.Composable&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.*&#10;import androidx.navigation.navArgument&#10;import com.valdo.notasinteligentesvaldo.screens.NoteDetailScreen&#10;import com.valdo.notasinteligentesvaldo.screens.NoteFormScreen&#10;import com.valdo.notasinteligentesvaldo.screens.NotesScreen&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;&#10;// Define duraciones de animación&#10;private const val NAV_ANIM_DURATION = 300 // Reducido para menos parpadeo&#10;&#10;@Composable&#10;fun AppNavigation(&#10;    viewModel: NoteViewModel,&#10;) {&#10;    val navController = rememberNavController()&#10;&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = &quot;notes?filter=all&quot;&#10;    ) {&#10;&#10;        // --- Pantalla de Notas (Lista) ---&#10;        composable(&#10;            route = &quot;notes?filter={filterType}&quot;,&#10;            arguments = listOf(navArgument(&quot;filterType&quot;) {&#10;                type = NavType.StringType&#10;                defaultValue = &quot;all&quot;&#10;                nullable = false&#10;            }),&#10;            // Eliminar todas las transiciones para evitar parpadeo&#10;            enterTransition = { null },&#10;            exitTransition = { null },&#10;            popEnterTransition = { null },&#10;            popExitTransition = { null }&#10;        ) { backStackEntry -&gt;&#10;            val filterType = backStackEntry.arguments?.getString(&quot;filterType&quot;) ?: &quot;all&quot;&#10;            NotesScreen(&#10;                viewModel = viewModel,&#10;                navController = navController,&#10;                filterType = filterType,&#10;                onAddNote = { navController.navigate(&quot;addNote&quot;) }&#10;            )&#10;        }&#10;&#10;        // --- Pantalla de Añadir/Editar Nota (Formulario) ---&#10;        composable(&#10;            route = &quot;addNote&quot;,&#10;            enterTransition = {&#10;                fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            exitTransition = {&#10;                fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;        ) {&#10;            NoteFormScreen(&#10;                onNoteSaved = { newNote -&gt;&#10;                    viewModel.insertNote(newNote)&#10;                    navController.popBackStack()&#10;                },&#10;                onBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // --- Pantalla de Detalle de Nota ---&#10;        composable(&#10;            route = &quot;noteDetail/{noteId}&quot;,&#10;            arguments = listOf(navArgument(&quot;noteId&quot;) {&#10;                type = NavType.IntType&#10;            }),&#10;            enterTransition = {&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            exitTransition = {&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popEnterTransition = {&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popExitTransition = {&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;        ) { backStackEntry -&gt;&#10;            val noteId = backStackEntry.arguments?.getInt(&quot;noteId&quot;)&#10;            if (noteId != null) {&#10;                NoteDetailScreen(&#10;                    noteId = noteId,&#10;                    viewModel = viewModel,&#10;                    onBack = { navController.popBackStack() }&#10;                )&#10;            } else {&#10;                navController.popBackStack()&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NoteDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NoteDetailScreen.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Clear&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Done&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Face&#10;// NUEVO: Importar iconos de corazón&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.outlined.FavoriteBorder&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Alignment.Companion.Center&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;// NUEVO: Importar Color si quieres un color específico como Rojo&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.res.painterResource&#10;import com.valdo.notasinteligentesvaldo.R&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import kotlinx.coroutines.delay&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.text.selection.SelectionContainer&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class)&#10;@Composable&#10;fun NoteDetailScreen(&#10;    noteId: Int,&#10;    onBack: () -&gt; Unit,&#10;    viewModel: NoteViewModel = viewModel()&#10;) {&#10;    val note by viewModel.currentNote.collectAsState()&#10;    var isEditMode by remember { mutableStateOf(false) }&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    val focusRequester = remember { FocusRequester() }&#10;    val scrollState = rememberScrollState()&#10;    val currentDate = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM&quot;, Locale.getDefault()).format(Date())&#10;    }&#10;&#10;    // Formateador de fecha&#10;    val dateFormatter = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM 'a las' HH:mm&quot;, Locale.getDefault())&#10;    }&#10;&#10;    var showDeleteDialog by remember { mutableStateOf(false) }&#10;&#10;    // Carga inicial de la nota&#10;    LaunchedEffect(noteId) {&#10;        viewModel.loadNote(noteId)&#10;    }&#10;&#10;    // Manejo del teclado y foco - CORRECCIÓN IMPORTANTE&#10;    LaunchedEffect(isEditMode) {&#10;        if (isEditMode) {&#10;            delay(300) // Pequeño delay para permitir la composición&#10;            try {&#10;                focusRequester.requestFocus()&#10;                keyboardController?.show()&#10;            } catch (e: Exception) {&#10;                // Maneja cualquier error de focus&#10;                keyboardController?.show()&#10;            }&#10;        } else {&#10;            keyboardController?.hide()&#10;        }&#10;    }&#10;&#10;    // --- Protección contra nota nula ---&#10;    // Guardamos la nota actual en una variable local para asegurar que no sea nula&#10;    // dentro del Scaffold, ya que la comprobación inicial ya se hizo.&#10;    val currentNote = note&#10;&#10;    if (currentNote == null) { // MODIFICADO: Usar la variable local&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Center) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    if (isEditMode) {&#10;                        Text(&quot;Editando nota&quot;)&#10;                    } else {&#10;                        Text(&#10;                            text = &quot;Hoy es $currentDate&quot;,&#10;                            style = MaterialTheme.typography.labelMedium.copy(&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, &quot;Volver&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // --- NUEVO: Botón Favorito ---&#10;                    IconButton(&#10;                        onClick = {&#10;                            // Llama a la función del ViewModel para cambiar el estado de favorito&#10;                            viewModel.toggleFavorite(currentNote.id)&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            // Cambia el icono según si la nota es favorita o no&#10;                            imageVector = if (currentNote.isFavorite) Icons.Filled.Favorite else Icons.Outlined.FavoriteBorder,&#10;                            contentDescription = if (currentNote.isFavorite) &quot;Quitar de favoritas&quot; else &quot;Marcar como favorita&quot;,&#10;                            // Opcional: Cambia el color si es favorita&#10;                            tint = if (currentNote.isFavorite) MaterialTheme.colorScheme.error else LocalContentColor.current // Puedes usar Color.Red o primary&#10;                        )&#10;                    }&#10;                    // --- FIN NUEVO ---&#10;&#10;                    // Botón de eliminar&#10;                    IconButton(&#10;                        onClick = { showDeleteDialog = true },&#10;                        // modifier = Modifier.padding(end = 8.dp) // Quitar padding si quieres que estén más juntos&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.Delete,&#10;                            contentDescription = &quot;Eliminar nota&quot;,&#10;                            tint = MaterialTheme.colorScheme.error&#10;                        )&#10;                    }&#10;&#10;                    // Botón de formato (solo en modo edición)&#10;                    if (isEditMode) {&#10;                        IconButton(&#10;                            onClick = {&#10;                                viewModel.updateCurrentNote { current -&gt;&#10;                                    current.copy(isMarkdownEnabled = !current.isMarkdownEnabled)&#10;                                }&#10;                            }&#10;                        ) {&#10;                            val markdownIcon = if (currentNote.isMarkdownEnabled) R.drawable.code_off_24px else R.drawable.code_24px&#10;                            Icon(&#10;                                painter = painterResource(id = markdownIcon),&#10;                                contentDescription = &quot;Formato Markdown&quot;,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Botón de edición/guardado&#10;                    IconButton(&#10;                        onClick = {&#10;                            if (isEditMode) {&#10;                                viewModel.saveCurrentNote() // Guarda la nota actual (incluyendo estado de favorito si cambió)&#10;                            }&#10;                            isEditMode = !isEditMode&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            if (isEditMode) Icons.Default.Check else Icons.Default.Edit,&#10;                            contentDescription = if (isEditMode) &quot;Guardar&quot; else &quot;Editar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            if (isEditMode) {&#10;                // MODO EDICIÓN&#10;                BasicTextField(&#10;                    value = currentNote.title, // MODIFICADO: usar currentNote&#10;                    onValueChange = { newTitle -&gt;&#10;                        viewModel.updateCurrentNote { it.copy(title = newTitle) }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    textStyle = MaterialTheme.typography.titleLarge.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    ),&#10;                    decorationBox = { innerTextField -&gt;&#10;                        Box {&#10;                            if (currentNote.title.isEmpty()) { // MODIFICADO: usar currentNote&#10;                                Text(&#10;                                    &quot;Título (opcional)&quot;,&#10;                                    style = MaterialTheme.typography.titleLarge.copy(&#10;                                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;                                )&#10;                            }&#10;                            innerTextField()&#10;                        }&#10;                    }&#10;                )&#10;&#10;                Divider(modifier = Modifier.padding(horizontal = 16.dp))&#10;&#10;                // Editor de contenido (Markdown o texto normal)&#10;                if (currentNote.isMarkdownEnabled) { // MODIFICADO: usar currentNote&#10;                    var preview by remember { mutableStateOf(false) }&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(8.dp),&#10;                        horizontalArrangement = Arrangement.End&#10;                    ) {&#10;                        IconButton(onClick = { preview = !preview }) {&#10;                            val previewIcon = if (preview) R.drawable.visibility_off_24px else R.drawable.visibility_24px&#10;                            Icon(&#10;                                painter = painterResource(id = previewIcon),&#10;                                contentDescription = &quot;Vista previa&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                    if (preview) {&#10;                        val isDark = isSystemInDarkTheme()&#10;                        MarkdownText(&#10;                            markdown = currentNote.content,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                color = if (isDark) Color.White else MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    } else {&#10;                        BasicTextField(&#10;                            value = currentNote.content, // MODIFICADO: usar currentNote&#10;                            onValueChange = { newContent -&gt;&#10;                                viewModel.updateCurrentNote { it.copy(content = newContent) }&#10;                            },&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(16.dp)&#10;                                .focusRequester(focusRequester),&#10;                            textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontSize = 18.sp,&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    }&#10;                } else {&#10;                    BasicTextField(&#10;                        value = currentNote.content, // MODIFICADO: usar currentNote&#10;                        onValueChange = { newContent -&gt;&#10;                            viewModel.updateCurrentNote { it.copy(content = newContent) }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp)&#10;                            .focusRequester(focusRequester),&#10;                        textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                            fontSize = 18.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    )&#10;                }&#10;            } else {&#10;                // MODO LECTURA&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp)&#10;                        .verticalScroll(scrollState)&#10;                ) {&#10;                    // Ya no necesitamos el let porque usamos currentNote que sabemos no es null aquí&#10;                    if (currentNote.title.isNotEmpty() &amp;&amp; currentNote.title != &quot;Nota sin título&quot;) {&#10;                        Text(&#10;                            text = currentNote.title,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;&#10;                    if (currentNote.isMarkdownEnabled) {&#10;                        val isDark = isSystemInDarkTheme()&#10;                        SelectionContainer {&#10;                            MarkdownText(&#10;                                markdown = currentNote.content,&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    color = if (isDark) Color.White else MaterialTheme.colorScheme.onSurface&#10;                                )&#10;                            )&#10;                        }&#10;                    } else {&#10;                        SelectionContainer {&#10;                            Text(&#10;                                text = currentNote.content,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    lineHeight = 28.sp,&#10;                                    color = MaterialTheme.colorScheme.onSurface&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                    // Pie de nota con metadatos&#10;                    Column(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.End&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Creada: ${dateFormatter.format(Date(currentNote.timestampInit))}&quot;,&#10;                            style = MaterialTheme.typography.labelSmall.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Modificada: ${dateFormatter.format(Date(currentNote.timestamp))}&quot;,&#10;                            style = MaterialTheme.typography.labelSmall.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                        if (currentNote.isMarkdownEnabled) {&#10;                            Text(&#10;                                text = &quot;Formato: Markdown&quot;,&#10;                                style = MaterialTheme.typography.labelSmall.copy(&#10;                                    color = MaterialTheme.colorScheme.primary.copy(alpha = 0.8f)&#10;                                )&#10;                            )&#10;                        }&#10;                        // NUEVO: Mostrar si es favorita en los metadatos&#10;                        if (currentNote.isFavorite) {&#10;                            Text(&#10;                                text = &quot;Favorita ⭐&quot;, // Puedes usar un emoji o texto&#10;                                style = MaterialTheme.typography.labelSmall.copy(&#10;                                    color = MaterialTheme.colorScheme.error.copy(alpha = 0.8f) // Usar un color distintivo&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Diálogo de confirmación&#10;            if (showDeleteDialog) {&#10;                AlertDialog(&#10;                    onDismissRequest = { showDeleteDialog = false },&#10;                    title = { Text(&quot;Eliminar nota&quot;) },&#10;                    text = { Text(&quot;¿Estás seguro de que quieres eliminar esta nota permanentemente?&quot;) },&#10;                    confirmButton = {&#10;                        TextButton(&#10;                            onClick = {&#10;                                // No necesitamos el let aquí porque currentNote no es null&#10;                                viewModel.deleteNote(currentNote)&#10;                                onBack() // Vuelve atrás después de eliminar&#10;                                showDeleteDialog = false&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Eliminar&quot;, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        TextButton(&#10;                            onClick = { showDeleteDialog = false }&#10;                        ) {&#10;                            Text(&quot;Cancelar&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Clear&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Done&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Face&#10;// NUEVO: Importar iconos de corazón&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.outlined.FavoriteBorder&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Alignment.Companion.Center&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;// NUEVO: Importar Color si quieres un color específico como Rojo&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.res.painterResource&#10;import com.valdo.notasinteligentesvaldo.R&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import kotlinx.coroutines.delay&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.text.selection.SelectionContainer&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class)&#10;@Composable&#10;fun NoteDetailScreen(&#10;    noteId: Int,&#10;    onBack: () -&gt; Unit,&#10;    viewModel: NoteViewModel = viewModel()&#10;) {&#10;    val note by viewModel.currentNote.collectAsState()&#10;    var isEditMode by remember { mutableStateOf(false) }&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    val focusRequester = remember { FocusRequester() }&#10;    val scrollState = rememberScrollState()&#10;    val currentDate = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM&quot;, Locale.getDefault()).format(Date())&#10;    }&#10;&#10;    // Formateador de fecha&#10;    val dateFormatter = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM 'a las' HH:mm&quot;, Locale.getDefault())&#10;    }&#10;&#10;    var showDeleteDialog by remember { mutableStateOf(false) }&#10;&#10;    // Carga inicial de la nota&#10;    LaunchedEffect(noteId) {&#10;        viewModel.loadNote(noteId)&#10;    }&#10;&#10;    // Manejo del teclado y foco - CORRECCIÓN IMPORTANTE&#10;    LaunchedEffect(isEditMode) {&#10;        if (isEditMode) {&#10;            delay(300) // Pequeño delay para permitir la composición&#10;            try {&#10;                focusRequester.requestFocus()&#10;                keyboardController?.show()&#10;            } catch (e: Exception) {&#10;                // Maneja cualquier error de focus&#10;                keyboardController?.show()&#10;            }&#10;        } else {&#10;            keyboardController?.hide()&#10;        }&#10;    }&#10;&#10;    // --- Protección contra nota nula ---&#10;    // Guardamos la nota actual en una variable local para asegurar que no sea nula&#10;    // dentro del Scaffold, ya que la comprobación inicial ya se hizo.&#10;    val currentNote = note&#10;&#10;    if (currentNote == null) { // MODIFICADO: Usar la variable local&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Center) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    if (isEditMode) {&#10;                        Text(&quot;Editando nota&quot;)&#10;                    } else {&#10;                        Text(&#10;                            text = &quot;Hoy es $currentDate&quot;,&#10;                            style = MaterialTheme.typography.labelMedium.copy(&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, &quot;Volver&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // --- NUEVO: Botón Favorito ---&#10;                    IconButton(&#10;                        onClick = {&#10;                            // Llama a la función del ViewModel para cambiar el estado de favorito&#10;                            viewModel.toggleFavorite(currentNote.id)&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            // Cambia el icono según si la nota es favorita o no&#10;                            imageVector = if (currentNote.isFavorite) Icons.Filled.Favorite else Icons.Outlined.FavoriteBorder,&#10;                            contentDescription = if (currentNote.isFavorite) &quot;Quitar de favoritas&quot; else &quot;Marcar como favorita&quot;,&#10;                            // Opcional: Cambia el color si es favorita&#10;                            tint = if (currentNote.isFavorite) MaterialTheme.colorScheme.error else LocalContentColor.current // Puedes usar Color.Red o primary&#10;                        )&#10;                    }&#10;                    // --- FIN NUEVO ---&#10;&#10;                    // Botón de eliminar&#10;                    IconButton(&#10;                        onClick = { showDeleteDialog = true },&#10;                        // modifier = Modifier.padding(end = 8.dp) // Quitar padding si quieres que estén más juntos&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.Delete,&#10;                            contentDescription = &quot;Eliminar nota&quot;,&#10;                            tint = MaterialTheme.colorScheme.error&#10;                        )&#10;                    }&#10;&#10;                    // Botón de formato (solo en modo edición)&#10;                    if (isEditMode) {&#10;                        IconButton(&#10;                            onClick = {&#10;                                viewModel.updateCurrentNote { current -&gt;&#10;                                    current.copy(isMarkdownEnabled = !current.isMarkdownEnabled)&#10;                                }&#10;                            }&#10;                        ) {&#10;                            val markdownIcon = if (currentNote.isMarkdownEnabled) R.drawable.code_off_24px else R.drawable.code_24px&#10;                            Icon(&#10;                                painter = painterResource(id = markdownIcon),&#10;                                contentDescription = &quot;Formato Markdown&quot;,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Botón de edición/guardado&#10;                    IconButton(&#10;                        onClick = {&#10;                            if (isEditMode) {&#10;                                viewModel.saveCurrentNote() // Guarda la nota actual (incluyendo estado de favorito si cambió)&#10;                            }&#10;                            isEditMode = !isEditMode&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            if (isEditMode) Icons.Default.Check else Icons.Default.Edit,&#10;                            contentDescription = if (isEditMode) &quot;Guardar&quot; else &quot;Editar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            if (isEditMode) {&#10;                // MODO EDICIÓN&#10;                BasicTextField(&#10;                    value = currentNote.title, // MODIFICADO: usar currentNote&#10;                    onValueChange = { newTitle -&gt;&#10;                        viewModel.updateCurrentNote { it.copy(title = newTitle) }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    textStyle = MaterialTheme.typography.titleLarge.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    ),&#10;                    decorationBox = { innerTextField -&gt;&#10;                        Box {&#10;                            if (currentNote.title.isEmpty()) { // MODIFICADO: usar currentNote&#10;                                Text(&#10;                                    &quot;Título (opcional)&quot;,&#10;                                    style = MaterialTheme.typography.titleLarge.copy(&#10;                                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;                                )&#10;                            }&#10;                            innerTextField()&#10;                        }&#10;                    }&#10;                )&#10;&#10;                Divider(modifier = Modifier.padding(horizontal = 16.dp))&#10;&#10;                // Editor de contenido (Markdown o texto normal)&#10;                if (currentNote.isMarkdownEnabled) { // MODIFICADO: usar currentNote&#10;                    var preview by remember { mutableStateOf(false) }&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(8.dp),&#10;                        horizontalArrangement = Arrangement.End&#10;                    ) {&#10;                        IconButton(onClick = { preview = !preview }) {&#10;                            val previewIcon = if (preview) R.drawable.visibility_off_24px else R.drawable.visibility_24px&#10;                            Icon(&#10;                                painter = painterResource(id = previewIcon),&#10;                                contentDescription = &quot;Vista previa&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                    if (preview) {&#10;                        val isDark = isSystemInDarkTheme()&#10;                        MarkdownText(&#10;                            markdown = currentNote.content,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                color = if (isDark) Color.White else MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    } else {&#10;                        BasicTextField(&#10;                            value = currentNote.content, // MODIFICADO: usar currentNote&#10;                            onValueChange = { newContent -&gt;&#10;                                viewModel.updateCurrentNote { it.copy(content = newContent) }&#10;                            },&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(16.dp)&#10;                                .focusRequester(focusRequester),&#10;                            textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontSize = 18.sp,&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    }&#10;                } else {&#10;                    BasicTextField(&#10;                        value = currentNote.content, // MODIFICADO: usar currentNote&#10;                        onValueChange = { newContent -&gt;&#10;                            viewModel.updateCurrentNote { it.copy(content = newContent) }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp)&#10;                            .focusRequester(focusRequester),&#10;                        textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                            fontSize = 18.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    )&#10;                }&#10;            } else {&#10;                // MODO LECTURA&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp)&#10;                        .verticalScroll(scrollState)&#10;                ) {&#10;                    // Ya no necesitamos el let porque usamos currentNote que sabemos no es null aquí&#10;                    if (currentNote.title.isNotEmpty() &amp;&amp; currentNote.title != &quot;Nota sin título&quot;) {&#10;                        Text(&#10;                            text = currentNote.title,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;&#10;                    if (currentNote.isMarkdownEnabled) {&#10;                        val isDark = isSystemInDarkTheme()&#10;                        // Mostrar aviso si es Markdown&#10;                        Text(&#10;                            text = &quot;La selección solo está disponible en notas normales :(, seguimos mejorando&quot;,&#10;                            color = MaterialTheme.colorScheme.error,&#10;                            style = MaterialTheme.typography.labelMedium,&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                        MarkdownText(&#10;                            markdown = currentNote.content,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                color = if (isDark) Color.White else MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    } else {&#10;                        SelectionContainer {&#10;                            Text(&#10;                                text = currentNote.content,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    lineHeight = 28.sp,&#10;                                    color = MaterialTheme.colorScheme.onSurface&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                    // Pie de nota con metadatos&#10;                    Column(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.End&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Creada: ${dateFormatter.format(Date(currentNote.timestampInit))}&quot;,&#10;                            style = MaterialTheme.typography.labelSmall.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Modificada: ${dateFormatter.format(Date(currentNote.timestamp))}&quot;,&#10;                            style = MaterialTheme.typography.labelSmall.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                        if (currentNote.isMarkdownEnabled) {&#10;                            Text(&#10;                                text = &quot;Formato: Markdown&quot;,&#10;                                style = MaterialTheme.typography.labelSmall.copy(&#10;                                    color = MaterialTheme.colorScheme.primary.copy(alpha = 0.8f)&#10;                                )&#10;                            )&#10;                        }&#10;                        // NUEVO: Mostrar si es favorita en los metadatos&#10;                        if (currentNote.isFavorite) {&#10;                            Text(&#10;                                text = &quot;Favorita ⭐&quot;, // Puedes usar un emoji o texto&#10;                                style = MaterialTheme.typography.labelSmall.copy(&#10;                                    color = MaterialTheme.colorScheme.error.copy(alpha = 0.8f) // Usar un color distintivo&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Diálogo de confirmación&#10;            if (showDeleteDialog) {&#10;                AlertDialog(&#10;                    onDismissRequest = { showDeleteDialog = false },&#10;                    title = { Text(&quot;Eliminar nota&quot;) },&#10;                    text = { Text(&quot;¿Estás seguro de que quieres eliminar esta nota permanentemente?&quot;) },&#10;                    confirmButton = {&#10;                        TextButton(&#10;                            onClick = {&#10;                                // No necesitamos el let aquí porque currentNote no es null&#10;                                viewModel.deleteNote(currentNote)&#10;                                onBack() // Vuelve atrás después de eliminar&#10;                                showDeleteDialog = false&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Eliminar&quot;, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        TextButton(&#10;                            onClick = { showDeleteDialog = false }&#10;                        ) {&#10;                            Text(&quot;Cancelar&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NoteFormScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NoteFormScreen.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Face&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;import androidx.compose.ui.geometry.Rect&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.SolidColor&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.valdo.notasinteligentesvaldo.R&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalView&#10;import androidx.compose.ui.platform.LocalFocusManager&#10;import androidx.compose.ui.platform.LocalLayoutDirection&#10;import androidx.compose.foundation.relocation.BringIntoViewRequester&#10;import androidx.compose.foundation.relocation.bringIntoViewRequester&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.text.input.TextFieldValue&#10;import kotlinx.coroutines.delay&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class, androidx.compose.foundation.ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NoteFormScreen(&#10;    onNoteSaved: (Note) -&gt; Unit,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var content by remember { mutableStateOf(&quot;&quot;) }&#10;    var textFieldValue by remember { mutableStateOf(TextFieldValue()) }&#10;    var isMarkdownEnabled by remember { mutableStateOf(false) }&#10;    // Sincroniza el contenido cuando cambias de modo&#10;    LaunchedEffect(isMarkdownEnabled) {&#10;        if (!isMarkdownEnabled) {&#10;            // Al salir de markdown, actualiza el textFieldValue con el contenido&#10;            textFieldValue = TextFieldValue(content)&#10;        } else {&#10;            // Al entrar a markdown, actualiza el contenido con el texto plano&#10;            content = textFieldValue.text&#10;        }&#10;    }&#10;    val focusRequester = remember { FocusRequester() }&#10;    val currentDate = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM&quot;, Locale.getDefault()).format(Date())&#10;    }&#10;    val titleAlpha by animateFloatAsState(&#10;        targetValue = if (title.isBlank()) 0.5f else 1f,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, &quot;Volver&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Botón de toggle Markdown&#10;                    IconButton(&#10;                        onClick = { isMarkdownEnabled = !isMarkdownEnabled },&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    ) {&#10;                        val markdownIcon = if (isMarkdownEnabled) R.drawable.code_off_24px else R.drawable.code_24px&#10;                        Icon(&#10;                            painter = painterResource(id = markdownIcon),&#10;                            contentDescription = &quot;Markdown&quot;,&#10;                            tint = if (isMarkdownEnabled) MaterialTheme.colorScheme.primary&#10;                            else MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    // Botón de guardar&#10;                    IconButton(&#10;                        onClick = {&#10;                            val newNote = Note(&#10;                                title = title.ifEmpty { &quot;Nota sin título&quot; },&#10;                                content = content,&#10;                                timestamp = System.currentTimeMillis(),&#10;                                timestampInit = System.currentTimeMillis(),&#10;                                isMarkdownEnabled = isMarkdownEnabled&#10;                            )&#10;                            onNoteSaved(newNote)&#10;                            // Eliminado: onBack() aquí para evitar doble navegación&#10;                        },&#10;                        enabled = content.isNotBlank() || title.isNotBlank()&#10;                    ) {&#10;                        Icon(Icons.Default.Check, &quot;Guardar&quot;)&#10;                    }&#10;                },&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = currentDate,&#10;                            style = MaterialTheme.typography.labelMedium.copy(&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        )&#10;                        // Título siempre visible (pero transparente cuando está vacío)&#10;                        Text(&#10;                            text = title.ifEmpty { &quot; &quot; }, // Espacio para mantener altura&#10;                            style = MaterialTheme.typography.titleLarge.copy(&#10;                                color = if (title.isBlank()) Color.Transparent&#10;                                else MaterialTheme.colorScheme.onSurface,&#10;                                fontWeight = FontWeight.Bold,&#10;                                fontSize = 20.sp&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Campo de título&#10;            BasicTextField(&#10;                value = title,&#10;                onValueChange = { title = it },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                textStyle = MaterialTheme.typography.titleLarge.copy(&#10;                    color = MaterialTheme.colorScheme.onSurface,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 20.sp&#10;                ),&#10;                decorationBox = { innerTextField -&gt;&#10;                    Box {&#10;                        if (title.isEmpty()) {&#10;                            Text(&#10;                                text = title.ifEmpty { &quot;Añade un título...&quot; },&#10;                                style = MaterialTheme.typography.titleLarge.copy(&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = titleAlpha),&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    fontSize = 20.sp&#10;                                )&#10;                            )&#10;                        }&#10;                        innerTextField()&#10;                    }&#10;                }&#10;            )&#10;&#10;            Divider(modifier = Modifier.padding(horizontal = 16.dp))&#10;&#10;            // Área de contenido con soporte Markdown&#10;            if (isMarkdownEnabled) {&#10;                MarkdownEditor(content, onContentChange = { content = it })&#10;            } else {&#10;                val scrollState = rememberScrollState()&#10;                val bringIntoViewRequester = remember { BringIntoViewRequester() }&#10;                var cursorRect by remember { mutableStateOf&lt;Rect?&gt;(null) }&#10;                val imeBottom = WindowInsets.ime.getBottom(LocalDensity.current)&#10;                var bringIntoViewTrigger by remember { mutableStateOf(0) }&#10;                Column(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .verticalScroll(scrollState)&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .bringIntoViewRequester(bringIntoViewRequester)&#10;                    ) {&#10;                        BasicTextField(&#10;                            value = textFieldValue,&#10;                            onValueChange = {&#10;                                textFieldValue = it&#10;                                content = it.text&#10;                                bringIntoViewTrigger++&#10;                            },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .focusRequester(focusRequester),&#10;                            textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontSize = 18.sp,&#10;                                lineHeight = 28.sp,&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            ),&#10;                            singleLine = false,&#10;                            maxLines = Int.MAX_VALUE,&#10;                            cursorBrush = SolidColor(MaterialTheme.colorScheme.onSurface),&#10;                            decorationBox = { innerTextField -&gt;&#10;                                if (textFieldValue.text.isEmpty()) {&#10;                                    Text(&#10;                                        &quot;Comienza a escribir tu nota aquí...&quot;,&#10;                                        style = MaterialTheme.typography.bodyLarge.copy(&#10;                                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                innerTextField()&#10;                            },&#10;                            onTextLayout = { textLayoutResult -&gt;&#10;                                val cursorOffset = textFieldValue.selection.end&#10;                                cursorRect = textLayoutResult.getCursorRect(cursorOffset)&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;                LaunchedEffect(bringIntoViewTrigger, imeBottom) {&#10;                    if (imeBottom &gt; 0 &amp;&amp; cursorRect != null) {&#10;                        delay(1)&#10;                        bringIntoViewRequester.bringIntoView(cursorRect!!)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        LaunchedEffect(Unit) {&#10;            focusRequester.requestFocus()&#10;            keyboardController?.show()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MarkdownEditor(&#10;    content: String,&#10;    onContentChange: (String) -&gt; Unit&#10;) {&#10;    var preview by remember { mutableStateOf(false) }&#10;    val isDark = isSystemInDarkTheme()&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Barra de herramientas Markdown (corregida)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            IconButton(onClick = { onContentChange(&quot;$content **texto** &quot;) }) {&#10;                Text(&quot;B&quot;, fontWeight = FontWeight.Bold)&#10;            }&#10;            IconButton(onClick = { onContentChange(&quot;$content *texto* &quot;) }) {&#10;                Text(&quot;I&quot;, fontStyle = FontStyle.Italic)&#10;            }&#10;            IconButton(onClick = { onContentChange(&quot;$content [texto](url) &quot;) }) {&#10;                Text(&quot;Link&quot;)&#10;            }&#10;            IconButton(onClick = { preview = !preview }) {&#10;                val previewIcon = if (preview) R.drawable.visibility_off_24px else R.drawable.visibility_24px&#10;                Icon(&#10;                    painter = painterResource(id = previewIcon),&#10;                    contentDescription = &quot;Vista previa&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (preview) {&#10;            // Vista previa del Markdown&#10;            MarkdownPreview(content)&#10;        } else {&#10;            // Editor de Markdown&#10;            BasicTextField(&#10;                value = content,&#10;                onValueChange = onContentChange,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                textStyle = TextStyle(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = if (isDark) Color.White else Color.Unspecified&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MarkdownPreview(content: String) {&#10;    val isDark = isSystemInDarkTheme()&#10;    MarkdownText(&#10;        markdown = content,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        style = TextStyle(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 16.sp,&#10;            color = if (isDark) Color.White else MaterialTheme.colorScheme.onSurface&#10;        )&#10;    )&#10;}" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Face&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;import androidx.compose.ui.geometry.Rect&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.SolidColor&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.valdo.notasinteligentesvaldo.R&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalView&#10;import androidx.compose.ui.platform.LocalFocusManager&#10;import androidx.compose.ui.platform.LocalLayoutDirection&#10;import androidx.compose.foundation.relocation.BringIntoViewRequester&#10;import androidx.compose.foundation.relocation.bringIntoViewRequester&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.text.input.TextFieldValue&#10;import kotlinx.coroutines.delay&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class, androidx.compose.foundation.ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NoteFormScreen(&#10;    onNoteSaved: (Note) -&gt; Unit,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var content by remember { mutableStateOf(&quot;&quot;) }&#10;    var textFieldValue by remember { mutableStateOf(TextFieldValue()) }&#10;    var isMarkdownEnabled by remember { mutableStateOf(false) }&#10;    // Sincroniza el contenido cuando cambias de modo&#10;    LaunchedEffect(isMarkdownEnabled) {&#10;        if (!isMarkdownEnabled) {&#10;            // Al salir de markdown, actualiza el textFieldValue con el contenido&#10;            textFieldValue = TextFieldValue(content)&#10;        } else {&#10;            // Al entrar a markdown, actualiza el contenido con el texto plano&#10;            content = textFieldValue.text&#10;        }&#10;    }&#10;    val focusRequester = remember { FocusRequester() }&#10;    val currentDate = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM&quot;, Locale.getDefault()).format(Date())&#10;    }&#10;    val titleAlpha by animateFloatAsState(&#10;        targetValue = if (title.isBlank()) 0.5f else 1f,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, &quot;Volver&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Botón de toggle Markdown&#10;                    IconButton(&#10;                        onClick = { isMarkdownEnabled = !isMarkdownEnabled },&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    ) {&#10;                        val markdownIcon = if (isMarkdownEnabled) R.drawable.code_off_24px else R.drawable.code_24px&#10;                        Icon(&#10;                            painter = painterResource(id = markdownIcon),&#10;                            contentDescription = &quot;Markdown&quot;,&#10;                            tint = if (isMarkdownEnabled) MaterialTheme.colorScheme.primary&#10;                            else MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    // Botón de guardar&#10;                    IconButton(&#10;                        onClick = {&#10;                            val newNote = Note(&#10;                                title = title.ifEmpty { &quot;Nota sin título&quot; },&#10;                                content = content,&#10;                                timestamp = System.currentTimeMillis(),&#10;                                timestampInit = System.currentTimeMillis(),&#10;                                isMarkdownEnabled = isMarkdownEnabled&#10;                            )&#10;                            onNoteSaved(newNote)&#10;                            // Eliminado: onBack() aquí para evitar doble navegación&#10;                        },&#10;                        enabled = content.isNotBlank() || title.isNotBlank()&#10;                    ) {&#10;                        Icon(Icons.Default.Check, &quot;Guardar&quot;)&#10;                    }&#10;                },&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = currentDate,&#10;                            style = MaterialTheme.typography.labelMedium.copy(&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        )&#10;                        // Título siempre visible (pero transparente cuando está vacío)&#10;                        Text(&#10;                            text = title.ifEmpty { &quot; &quot; }, // Espacio para mantener altura&#10;                            style = MaterialTheme.typography.titleLarge.copy(&#10;                                color = if (title.isBlank()) Color.Transparent&#10;                                else MaterialTheme.colorScheme.onSurface,&#10;                                fontWeight = FontWeight.Bold,&#10;                                fontSize = 20.sp&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Campo de título&#10;            BasicTextField(&#10;                value = title,&#10;                onValueChange = { title = it },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                textStyle = MaterialTheme.typography.titleLarge.copy(&#10;                    color = MaterialTheme.colorScheme.onSurface,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 20.sp&#10;                ),&#10;                decorationBox = { innerTextField -&gt;&#10;                    Box {&#10;                        if (title.isEmpty()) {&#10;                            Text(&#10;                                text = title.ifEmpty { &quot;Añade un título...&quot; },&#10;                                style = MaterialTheme.typography.titleLarge.copy(&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = titleAlpha),&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    fontSize = 20.sp&#10;                                )&#10;                            )&#10;                        }&#10;                        innerTextField()&#10;                    }&#10;                }&#10;            )&#10;&#10;            Divider(modifier = Modifier.padding(horizontal = 16.dp))&#10;&#10;            // Área de contenido con soporte Markdown&#10;            if (isMarkdownEnabled) {&#10;                MarkdownEditor(content, onContentChange = { content = it })&#10;            } else {&#10;                val scrollState = rememberScrollState()&#10;                val bringIntoViewRequester = remember { BringIntoViewRequester() }&#10;                var cursorRect by remember { mutableStateOf&lt;Rect?&gt;(null) }&#10;                val imeBottom = WindowInsets.ime.getBottom(LocalDensity.current)&#10;                var bringIntoViewTrigger by remember { mutableStateOf(0) }&#10;                Column(&#10;                    modifier = Modifier&#10;                        .weight(1f)&#10;                        .verticalScroll(scrollState)&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .bringIntoViewRequester(bringIntoViewRequester)&#10;                    ) {&#10;                        BasicTextField(&#10;                            value = textFieldValue,&#10;                            onValueChange = {&#10;                                textFieldValue = it&#10;                                content = it.text&#10;                                bringIntoViewTrigger++&#10;                            },&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .focusRequester(focusRequester),&#10;                            textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontSize = 18.sp,&#10;                                lineHeight = 28.sp,&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            ),&#10;                            singleLine = false,&#10;                            maxLines = Int.MAX_VALUE,&#10;                            cursorBrush = SolidColor(MaterialTheme.colorScheme.onSurface),&#10;                            decorationBox = { innerTextField -&gt;&#10;                                if (textFieldValue.text.isEmpty()) {&#10;                                    Text(&#10;                                        &quot;Comienza a escribir tu nota aquí...&quot;,&#10;                                        style = MaterialTheme.typography.bodyLarge.copy(&#10;                                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                innerTextField()&#10;                            },&#10;                            onTextLayout = { textLayoutResult -&gt;&#10;                                val cursorOffset = textFieldValue.selection.end&#10;                                cursorRect = textLayoutResult.getCursorRect(cursorOffset)&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;                LaunchedEffect(bringIntoViewTrigger, imeBottom) {&#10;                    if (imeBottom &gt; 0 &amp;&amp; cursorRect != null) {&#10;                        delay(1)&#10;                        bringIntoViewRequester.bringIntoView(cursorRect!!)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        LaunchedEffect(Unit) {&#10;            focusRequester.requestFocus()&#10;            keyboardController?.show()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MarkdownEditor(&#10;    content: String,&#10;    onContentChange: (String) -&gt; Unit&#10;) {&#10;    var preview by remember { mutableStateOf(false) }&#10;    val isDark = isSystemInDarkTheme()&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Barra de herramientas Markdown (corregida)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            IconButton(onClick = { onContentChange(&quot;$content **texto** &quot;) }) {&#10;                Text(&quot;B&quot;, fontWeight = FontWeight.Bold)&#10;            }&#10;            IconButton(onClick = { onContentChange(&quot;$content *texto* &quot;) }) {&#10;                Text(&quot;I&quot;, fontStyle = FontStyle.Italic)&#10;            }&#10;            IconButton(onClick = { onContentChange(&quot;$content [texto](url) &quot;) }) {&#10;                Text(&quot;Link&quot;)&#10;            }&#10;            IconButton(onClick = { preview = !preview }) {&#10;                val previewIcon = if (preview) R.drawable.visibility_off_24px else R.drawable.visibility_24px&#10;                Icon(&#10;                    painter = painterResource(id = previewIcon),&#10;                    contentDescription = &quot;Vista previa&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (preview) {&#10;            // Vista previa del Markdown&#10;            MarkdownPreview(content)&#10;        } else {&#10;            // Editor de Markdown&#10;            BasicTextField(&#10;                value = content,&#10;                onValueChange = onContentChange,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                textStyle = TextStyle(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = if (isDark) Color.White else Color.Unspecified&#10;                ),&#10;                cursorBrush = SolidColor(if (isDark) Color.White else Color.Black)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MarkdownPreview(content: String) {&#10;    val isDark = isSystemInDarkTheme()&#10;    MarkdownText(&#10;        markdown = content,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        style = TextStyle(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 16.sp,&#10;            color = if (isDark) Color.White else MaterialTheme.colorScheme.onSurface&#10;        )&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NotesScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NotesScreen.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.staggeredgrid.LazyVerticalStaggeredGrid&#10;import androidx.compose.foundation.lazy.staggeredgrid.StaggeredGridCells&#10;import androidx.compose.foundation.lazy.staggeredgrid.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import com.valdo.notasinteligentesvaldo.components.NoteCard&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.ui.res.painterResource&#10;import com.valdo.notasinteligentesvaldo.R&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NotesScreen(&#10;    viewModel: NoteViewModel,&#10;    navController: NavController,&#10;    filterType: String,&#10;    onAddNote: () -&gt; Unit&#10;) {&#10;    // CAMBIO CLAVE: Evitar remember que causa recomposición&#10;    val allNotesState by viewModel.allNotes.collectAsState()&#10;    val favoriteNotesState by viewModel.favoriteNotes.collectAsState()&#10;&#10;    // Determinar qué notas mostrar sin remember&#10;    val notesToDisplay = when (filterType) {&#10;        &quot;favorites&quot; -&gt; favoriteNotesState&#10;        else -&gt; allNotesState&#10;    }&#10;&#10;    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Cargar datos SOLO al inicio, no en cada cambio de filtro&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadAllNotes()&#10;        viewModel.loadFavorites()&#10;    }&#10;&#10;    // Para saber qué item del drawer está seleccionado - SIMPLIFICADO&#10;    val currentFilter = filterType // Usar directamente el parámetro&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        drawerContent = {&#10;            ModalDrawerSheet {&#10;                Spacer(Modifier.height(16.dp))&#10;                // Item Inicio&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Inicio&quot;) },&#10;                    selected = currentFilter == &quot;all&quot;,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        if (currentFilter != &quot;all&quot;) {&#10;                            navController.navigate(&quot;notes?filter=all&quot;)&#10;                        }&#10;                    },&#10;                    icon = { Icon(Icons.Default.Home, contentDescription = &quot;Inicio&quot;) }&#10;                )&#10;                // Item Favoritas&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Favoritas&quot;) },&#10;                    selected = currentFilter == &quot;favorites&quot;,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        if (currentFilter != &quot;favorites&quot;) {&#10;                            navController.navigate(&quot;notes?filter=favorites&quot;)&#10;                        }&#10;                    },&#10;                    icon = { Icon(Icons.Default.Favorite, contentDescription = &quot;Favoritas&quot;) }&#10;                )&#10;                // Item Categorías&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Categorías&quot;) },&#10;                    selected = false,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                    },&#10;                    icon = { Icon(Icons.Default.Menu, contentDescription = &quot;Categorías&quot;) }&#10;                )&#10;                HorizontalDivider()&#10;                // Item Ajustes&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Ajustes&quot;) },&#10;                    selected = false,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                    },&#10;                    icon = { Icon(Icons.Default.Settings, contentDescription = &quot;Ajustes&quot;) }&#10;                )&#10;            }&#10;        }&#10;    ) {&#10;        Scaffold(&#10;            containerColor = MaterialTheme.colorScheme.background,&#10;            contentColor = MaterialTheme.colorScheme.onBackground,&#10;            floatingActionButton = {&#10;                FloatingActionButton(&#10;                    onClick = { navController.navigate(&quot;addNote&quot;) },&#10;                    modifier = Modifier.defaultMinSize(minWidth = 150.dp, minHeight = 56.dp),&#10;                    containerColor = MaterialTheme.colorScheme.primary&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(horizontal = 16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Nueva nota :)&quot;,&#10;                            style = MaterialTheme.typography.labelLarge,&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            topBar = {&#10;                TopAppBar(&#10;                    title = { Text(if (filterType == &quot;favorites&quot;) &quot;Notas Favoritas&quot; else &quot;Mis Notas&quot;) },&#10;                    navigationIcon = {&#10;                        IconButton(&#10;                            onClick = { scope.launch { drawerState.open() } }&#10;                        ) {&#10;                            Icon(Icons.Default.Menu, contentDescription = &quot;Abrir menú&quot;)&#10;                        }&#10;                    },&#10;                    actions = {&#10;                        IconButton(&#10;                            onClick = {&#10;                                viewModel.loadAllNotes()&#10;                                viewModel.loadFavorites()&#10;                            }&#10;                        ) {&#10;                            Icon(Icons.Default.Refresh, contentDescription = &quot;Refrescar&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        ) { padding -&gt;&#10;            // CONTENIDO SIN RECOMPOSICIONES INNECESARIAS&#10;            when {&#10;                notesToDisplay.isEmpty() -&gt; {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .padding(padding)&#10;                            .fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        val emptyMessage = if (filterType == &quot;favorites&quot;) {&#10;                            &quot;Aún no tienes notas favoritas.&quot;&#10;                        } else {&#10;                            &quot;¡Crea tu primera nota!&quot;&#10;                        }&#10;                        EmptyNotesMessage(&#10;                            message = emptyMessage,&#10;                            onAddNoteClick = onAddNote,&#10;                            isFavorites = filterType == &quot;favorites&quot;&#10;                        )&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    NotesGrid(&#10;                        notes = notesToDisplay,&#10;                        onNoteClick = { note -&gt; navController.navigate(&quot;noteDetail/${note.id}&quot;) },&#10;                        modifier = Modifier.padding(padding)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EmptyNotesMessage(message: String, onAddNoteClick: () -&gt; Unit, isFavorites: Boolean = false) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;            val iconRes = if (isFavorites) R.drawable.sentiment_sad_24px else R.drawable.add_notes_24px&#10;            Icon(&#10;                painter = painterResource(id = iconRes),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .clickable { if (!isFavorites) onAddNoteClick() },&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Spacer(Modifier.height(16.dp))&#10;            Text(&#10;                text = message,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NotesGrid(notes: List&lt;Note&gt;, onNoteClick: (Note) -&gt; Unit, modifier: Modifier = Modifier) {&#10;    val configuration = LocalConfiguration.current&#10;    val columns = if (configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) 3 else 2&#10;&#10;    LazyVerticalStaggeredGrid(&#10;        columns = StaggeredGridCells.Fixed(columns),&#10;        modifier = modifier.fillMaxSize(),&#10;        contentPadding = PaddingValues(8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;        verticalItemSpacing = 8.dp&#10;    ) {&#10;        items(notes, key = { it.id }) { note -&gt;&#10;            NoteCard(note = note, onNoteClick = onNoteClick)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import android.content.res.Configuration&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.staggeredgrid.LazyVerticalStaggeredGrid&#10;import androidx.compose.foundation.lazy.staggeredgrid.StaggeredGridCells&#10;import androidx.compose.foundation.lazy.staggeredgrid.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import com.valdo.notasinteligentesvaldo.components.NoteCard&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.ui.res.painterResource&#10;import com.valdo.notasinteligentesvaldo.R&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NotesScreen(&#10;    viewModel: NoteViewModel,&#10;    navController: NavController,&#10;    filterType: String,&#10;    onAddNote: () -&gt; Unit&#10;) {&#10;    // Estados de notas&#10;    val allNotesState by viewModel.allNotes.collectAsState()&#10;    val favoriteNotesState by viewModel.favoriteNotes.collectAsState()&#10;    &#10;    // Estado de carga&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    var isRefreshing by remember { mutableStateOf(false) }&#10;&#10;    // Determinar qué notas mostrar&#10;    val notesToDisplay = when (filterType) {&#10;        &quot;favorites&quot; -&gt; favoriteNotesState&#10;        else -&gt; allNotesState&#10;    }&#10;&#10;    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Cargar datos al inicio y manejar estado de carga&#10;    LaunchedEffect(Unit) {&#10;        isLoading = true&#10;        viewModel.loadAllNotes()&#10;        viewModel.loadFavorites()&#10;        // Simular tiempo mínimo de carga para mostrar el indicador&#10;        kotlinx.coroutines.delay(500)&#10;        isLoading = false&#10;    }&#10;&#10;    // Detectar cuando se termina de cargar después de un refresh&#10;    LaunchedEffect(allNotesState, favoriteNotesState) {&#10;        if (isRefreshing) {&#10;            kotlinx.coroutines.delay(300) // Pequeño delay para mostrar que se refrescó&#10;            isRefreshing = false&#10;        }&#10;    }&#10;&#10;    val currentFilter = filterType&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        drawerContent = {&#10;            ModalDrawerSheet {&#10;                Spacer(Modifier.height(16.dp))&#10;                // Item Inicio&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Inicio&quot;) },&#10;                    selected = currentFilter == &quot;all&quot;,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        if (currentFilter != &quot;all&quot;) {&#10;                            navController.navigate(&quot;notes?filter=all&quot;)&#10;                        }&#10;                    },&#10;                    icon = { Icon(Icons.Default.Home, contentDescription = &quot;Inicio&quot;) }&#10;                )&#10;                // Item Favoritas&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Favoritas&quot;) },&#10;                    selected = currentFilter == &quot;favorites&quot;,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        if (currentFilter != &quot;favorites&quot;) {&#10;                            navController.navigate(&quot;notes?filter=favorites&quot;)&#10;                        }&#10;                    },&#10;                    icon = { Icon(Icons.Default.Favorite, contentDescription = &quot;Favoritas&quot;) }&#10;                )&#10;                // Item Categorías&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Categorías&quot;) },&#10;                    selected = false,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                    },&#10;                    icon = { Icon(Icons.Default.Menu, contentDescription = &quot;Categorías&quot;) }&#10;                )&#10;                HorizontalDivider()&#10;                // Item Ajustes&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Ajustes&quot;) },&#10;                    selected = false,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                    },&#10;                    icon = { Icon(Icons.Default.Settings, contentDescription = &quot;Ajustes&quot;) }&#10;                )&#10;            }&#10;        }&#10;    ) {&#10;        Scaffold(&#10;            containerColor = MaterialTheme.colorScheme.background,&#10;            contentColor = MaterialTheme.colorScheme.onBackground,&#10;            floatingActionButton = {&#10;                FloatingActionButton(&#10;                    onClick = { navController.navigate(&quot;addNote&quot;) },&#10;                    modifier = Modifier.defaultMinSize(minWidth = 150.dp, minHeight = 56.dp),&#10;                    containerColor = MaterialTheme.colorScheme.primary&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(horizontal = 16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Nueva nota :)&quot;,&#10;                            style = MaterialTheme.typography.labelLarge,&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            topBar = {&#10;                TopAppBar(&#10;                    title = { Text(if (filterType == &quot;favorites&quot;) &quot;Notas Favoritas&quot; else &quot;Mis Notas&quot;) },&#10;                    navigationIcon = {&#10;                        IconButton(&#10;                            onClick = { scope.launch { drawerState.open() } }&#10;                        ) {&#10;                            Icon(Icons.Default.Menu, contentDescription = &quot;Abrir menú&quot;)&#10;                        }&#10;                    },&#10;                    actions = {&#10;                        IconButton(&#10;                            onClick = {&#10;                                isRefreshing = true&#10;                                viewModel.loadAllNotes()&#10;                                viewModel.loadFavorites()&#10;                            }&#10;                        ) {&#10;                            if (isRefreshing) {&#10;                                CircularProgressIndicator(&#10;                                    modifier = Modifier.size(20.dp),&#10;                                    strokeWidth = 2.dp,&#10;                                    color = MaterialTheme.colorScheme.onSurface&#10;                                )&#10;                            } else {&#10;                                Icon(Icons.Default.Refresh, contentDescription = &quot;Refrescar&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        ) { padding -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .padding(padding)&#10;                    .fillMaxSize()&#10;            ) {&#10;                when {&#10;                    isLoading -&gt; {&#10;                        // Indicador de carga inicial&#10;                        Column(&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(48.dp),&#10;                                color = MaterialTheme.colorScheme.primary,&#10;                                strokeWidth = 4.dp&#10;                            )&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&#10;                                text = &quot;Cargando notas...&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                            )&#10;                        }&#10;                    }&#10;                    notesToDisplay.isEmpty() -&gt; {&#10;                        // Mensaje cuando no hay notas&#10;                        val emptyMessage = if (filterType == &quot;favorites&quot;) {&#10;                            &quot;Aún no tienes notas favoritas.&quot;&#10;                        } else {&#10;                            &quot;¡Crea tu primera nota!&quot;&#10;                        }&#10;                        EmptyNotesMessage(&#10;                            message = emptyMessage,&#10;                            onAddNoteClick = onAddNote,&#10;                            isFavorites = filterType == &quot;favorites&quot;&#10;                        )&#10;                    }&#10;                    else -&gt; {&#10;                        // Lista de notas con overlay de carga si se está refrescando&#10;                        Box {&#10;                            NotesGrid(&#10;                                notes = notesToDisplay,&#10;                                onNoteClick = { note -&gt; navController.navigate(&quot;noteDetail/${note.id}&quot;) },&#10;                                modifier = Modifier.fillMaxSize()&#10;                            )&#10;                            &#10;                            // Overlay de carga transparente durante refresh&#10;                            if (isRefreshing) {&#10;                                Box(&#10;                                    modifier = Modifier&#10;                                        .fillMaxSize()&#10;                                        .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.7f)),&#10;                                    contentAlignment = Alignment.Center&#10;                                ) {&#10;                                    CircularProgressIndicator(&#10;                                        color = MaterialTheme.colorScheme.primary&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun EmptyNotesMessage(message: String, onAddNoteClick: () -&gt; Unit, isFavorites: Boolean = false) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;            val iconRes = if (isFavorites) R.drawable.sentiment_sad_24px else R.drawable.add_notes_24px&#10;            Icon(&#10;                painter = painterResource(id = iconRes),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .clickable { if (!isFavorites) onAddNoteClick() },&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Spacer(Modifier.height(16.dp))&#10;            Text(&#10;                text = message,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NotesGrid(notes: List&lt;Note&gt;, onNoteClick: (Note) -&gt; Unit, modifier: Modifier = Modifier) {&#10;    val configuration = LocalConfiguration.current&#10;    val columns = if (configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) 3 else 2&#10;&#10;    LazyVerticalStaggeredGrid(&#10;        columns = StaggeredGridCells.Fixed(columns),&#10;        modifier = modifier.fillMaxSize(),&#10;        contentPadding = PaddingValues(8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;        verticalItemSpacing = 8.dp&#10;    ) {&#10;        items(notes, key = { it.id }) { note -&gt;&#10;            NoteCard(note = note, onNoteClick = onNoteClick)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>