<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/MainActivity.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.viewModels&#10;import androidx.lifecycle.lifecycleScope&#10;import com.valdo.notasinteligentesvaldo.data.DatabaseBuilder&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.navigation.AppNavigation&#10;import com.valdo.notasinteligentesvaldo.ui.theme.NotasInteligentesValdoTheme&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModelFactory&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.viewModels&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.valdo.notasinteligentesvaldo.data.NoteDao&#10;import com.valdo.notasinteligentesvaldo.ui.theme.NotasInteligentesValdoTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    private val noteViewModel: NoteViewModel by viewModels {&#10;        NoteViewModelFactory(DatabaseBuilder.getInstance(this).noteDao())&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        setContent {&#10;            NotasInteligentesValdoTheme {&#10;                AppNavigation(&#10;                    viewModel = noteViewModel // Pasamos el ViewModel creado&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.viewModels&#10;import androidx.lifecycle.lifecycleScope&#10;import com.valdo.notasinteligentesvaldo.data.DatabaseBuilder&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.navigation.AppNavigation&#10;import com.valdo.notasinteligentesvaldo.ui.theme.NotasInteligentesValdoTheme&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModelFactory&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.viewModels&#10;import androidx.lifecycle.ViewModelProvider&#10;import com.valdo.notasinteligentesvaldo.data.NoteDao&#10;import com.valdo.notasinteligentesvaldo.ui.theme.NotasInteligentesValdoTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    private val noteViewModel: NoteViewModel by viewModels {&#10;        NoteViewModelFactory(DatabaseBuilder.getInstance(this).noteDao())&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        setContent {&#10;            NotasInteligentesValdoTheme {&#10;                Surface(color = MaterialTheme.colorScheme.background) {&#10;                    AppNavigation(&#10;                        viewModel = noteViewModel // Pasamos el ViewModel creado&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/navigation/Navigation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/navigation/Navigation.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo.navigation&#10;&#10;import androidx.compose.animation.AnimatedContentTransitionScope // Importar para slideInto/slideOutOf&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.runtime.Composable&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.*&#10;import androidx.navigation.navArgument&#10;import com.valdo.notasinteligentesvaldo.screens.NoteDetailScreen&#10;import com.valdo.notasinteligentesvaldo.screens.NoteFormScreen&#10;import com.valdo.notasinteligentesvaldo.screens.NotesScreen&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;&#10;// Define duraciones de animación (opcional, para consistencia)&#10;private const val NAV_ANIM_DURATION = 400 // milisegundos&#10;&#10;@Composable&#10;fun AppNavigation(&#10;    viewModel: NoteViewModel,&#10;) {&#10;    val navController = rememberNavController()&#10;&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = &quot;notes&quot;, // Ruta inicial&#10;        // Aplicar transiciones por defecto si se desea (pueden ser anuladas por composable)&#10;        // enterTransition = { fadeIn(animationSpec = tween(NAV_ANIM_DURATION)) },&#10;        // exitTransition = { fadeOut(animationSpec = tween(NAV_ANIM_DURATION)) }&#10;    ) {&#10;&#10;        // --- Pantalla de Notas (Lista) ---&#10;        composable(&#10;            route = &quot;notes?filter={filterType}&quot;,&#10;            arguments = listOf(navArgument(&quot;filterType&quot;) {&#10;                type = NavType.StringType&#10;                defaultValue = &quot;all&quot;&#10;                nullable = false&#10;            }),&#10;            // Transiciones para ENTRAR a NotesScreen desde otra pantalla (ej: Detail)&#10;            enterTransition = {&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right, // Entra desde la derecha&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            // Transiciones para SALIR de NotesScreen hacia otra pantalla (ej: Detail)&#10;            exitTransition = {&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left, // Sale hacia la izquierda&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            // Transiciones cuando se vuelve a NotesScreen usando popBackStack (ej: desde Detail)&#10;            popEnterTransition = {&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            // Transiciones cuando NotesScreen es eliminada del stack al volver atrás&#10;            popExitTransition = {&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;            // NOTA: Las transiciones entre 'notes?filter=all' y 'notes?filter=favorites'&#10;            // usualmente no usan estas animaciones porque no es un cambio de destino completo&#10;            // en el backstack, sino una actualización. El Crossfade dentro de NotesScreen ayuda aquí.&#10;        ) { backStackEntry -&gt;&#10;            val filterType = backStackEntry.arguments?.getString(&quot;filterType&quot;) ?: &quot;all&quot;&#10;            NotesScreen(&#10;                viewModel = viewModel,&#10;                navController = navController,&#10;                filterType = filterType,&#10;                onAddNote = { navController.navigate(&quot;addNote&quot;) }&#10;            )&#10;        }&#10;&#10;        // --- Pantalla de Añadir/Editar Nota (Formulario) ---&#10;        composable(&#10;            route = &quot;addNote&quot;,&#10;            enterTransition = {&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left, // Entra desde la izquierda&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            exitTransition = {&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right, // Sale hacia la derecha&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popEnterTransition = { // Al volver de una pantalla superior (si la hubiera)&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popExitTransition = { // Al presionar back desde esta pantalla&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;        ) {&#10;            NoteFormScreen(&#10;                onNoteSaved = { newNote -&gt;&#10;                    viewModel.insertNote(newNote)&#10;                    navController.popBackStack() // Vuelve a la lista después de guardar&#10;                },&#10;                onBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // --- Pantalla de Detalle de Nota ---&#10;        composable(&#10;            route = &quot;noteDetail/{noteId}&quot;,&#10;            arguments = listOf(navArgument(&quot;noteId&quot;) { type = NavType.IntType }),&#10;            enterTransition = {&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left, // Entra desde la izquierda&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            exitTransition = {&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right, // Sale hacia la derecha&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popEnterTransition = { // Al volver de una pantalla superior (si la hubiera)&#10;                slideIntoContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Left,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popExitTransition = { // Al presionar back desde esta pantalla&#10;                slideOutOfContainer(&#10;                    AnimatedContentTransitionScope.SlideDirection.Right,&#10;                    animationSpec = tween(NAV_ANIM_DURATION)&#10;                ) + fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;        ) { backStackEntry -&gt;&#10;            val noteId = backStackEntry.arguments?.getInt(&quot;noteId&quot;)&#10;            if (noteId != null) {&#10;                NoteDetailScreen(&#10;                    noteId = noteId,&#10;                    viewModel = viewModel,&#10;                    onBack = { navController.popBackStack() }&#10;                )&#10;            } else {&#10;                navController.popBackStack()&#10;            }&#10;        }&#10;&#10;        // Añade otras rutas (categories, settings) con sus transiciones si es necesario&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo.navigation&#10;&#10;import androidx.compose.animation.AnimatedContentTransitionScope // Importar para slideInto/slideOutOf&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.runtime.Composable&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.*&#10;import androidx.navigation.navArgument&#10;import com.valdo.notasinteligentesvaldo.screens.NoteDetailScreen&#10;import com.valdo.notasinteligentesvaldo.screens.NoteFormScreen&#10;import com.valdo.notasinteligentesvaldo.screens.NotesScreen&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;&#10;// Define duraciones de animación (opcional, para consistencia)&#10;private const val NAV_ANIM_DURATION = 400 // milisegundos&#10;&#10;@Composable&#10;fun AppNavigation(&#10;    viewModel: NoteViewModel,&#10;) {&#10;    val navController = rememberNavController()&#10;&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = &quot;notes&quot;, // Ruta inicial&#10;        // Aplicar transiciones por defecto si se desea (pueden ser anuladas por composable)&#10;        // enterTransition = { fadeIn(animationSpec = tween(NAV_ANIM_DURATION)) },&#10;        // exitTransition = { fadeOut(animationSpec = tween(NAV_ANIM_DURATION)) }&#10;    ) {&#10;&#10;        // --- Pantalla de Notas (Lista) ---&#10;        composable(&#10;            route = &quot;notes?filter={filterType}&quot;,&#10;            arguments = listOf(navArgument(&quot;filterType&quot;) {&#10;                type = NavType.StringType&#10;                defaultValue = &quot;all&quot;&#10;                nullable = false&#10;            }),&#10;            enterTransition = {&#10;                fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            exitTransition = {&#10;                fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popEnterTransition = {&#10;                fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popExitTransition = {&#10;                fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;        ) { backStackEntry -&gt;&#10;            val filterType = backStackEntry.arguments?.getString(&quot;filterType&quot;) ?: &quot;all&quot;&#10;            NotesScreen(&#10;                viewModel = viewModel,&#10;                navController = navController,&#10;                filterType = filterType,&#10;                onAddNote = { navController.navigate(&quot;addNote&quot;) }&#10;            )&#10;        }&#10;&#10;        // --- Pantalla de Añadir/Editar Nota (Formulario) ---&#10;        composable(&#10;            route = &quot;addNote&quot;,&#10;            enterTransition = {&#10;                fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            exitTransition = {&#10;                fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popEnterTransition = {&#10;                fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popExitTransition = {&#10;                fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;        ) {&#10;            NoteFormScreen(&#10;                onNoteSaved = { newNote -&gt;&#10;                    viewModel.insertNote(newNote)&#10;                    navController.popBackStack() // Vuelve a la lista después de guardar&#10;                },&#10;                onBack = { navController.popBackStack() }&#10;            )&#10;        }&#10;&#10;        // --- Pantalla de Detalle de Nota ---&#10;        composable(&#10;            route = &quot;noteDetail/{noteId}&quot;,&#10;            arguments = listOf(navArgument(&quot;noteId&quot;) { type = NavType.IntType }),&#10;            enterTransition = {&#10;                fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            exitTransition = {&#10;                fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popEnterTransition = {&#10;                fadeIn(animationSpec = tween(NAV_ANIM_DURATION))&#10;            },&#10;            popExitTransition = {&#10;                fadeOut(animationSpec = tween(NAV_ANIM_DURATION))&#10;            }&#10;        ) { backStackEntry -&gt;&#10;            val noteId = backStackEntry.arguments?.getInt(&quot;noteId&quot;)&#10;            if (noteId != null) {&#10;                NoteDetailScreen(&#10;                    noteId = noteId,&#10;                    viewModel = viewModel,&#10;                    onBack = { navController.popBackStack() }&#10;                )&#10;            } else {&#10;                navController.popBackStack()&#10;            }&#10;        }&#10;&#10;        // Añade otras rutas (categories, settings) con sus transiciones si es necesario&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NoteDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NoteDetailScreen.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Clear&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Done&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Face&#10;// NUEVO: Importar iconos de corazón&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.outlined.FavoriteBorder&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Alignment.Companion.Center&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;// NUEVO: Importar Color si quieres un color específico como Rojo&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import kotlinx.coroutines.delay&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class)&#10;@Composable&#10;fun NoteDetailScreen(&#10;    noteId: Int,&#10;    onBack: () -&gt; Unit,&#10;    viewModel: NoteViewModel = viewModel()&#10;) {&#10;    val note by viewModel.currentNote.collectAsState()&#10;    var isEditMode by remember { mutableStateOf(false) }&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    val focusRequester = remember { FocusRequester() }&#10;    val scrollState = rememberScrollState()&#10;    val currentDate = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM&quot;, Locale.getDefault()).format(Date())&#10;    }&#10;&#10;    // Formateador de fecha&#10;    val dateFormatter = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM 'a las' HH:mm&quot;, Locale.getDefault())&#10;    }&#10;&#10;    var showDeleteDialog by remember { mutableStateOf(false) }&#10;&#10;    // Carga inicial de la nota&#10;    LaunchedEffect(noteId) {&#10;        viewModel.loadNote(noteId)&#10;    }&#10;&#10;    // Manejo del teclado y foco - CORRECCIÓN IMPORTANTE&#10;    LaunchedEffect(isEditMode) {&#10;        if (isEditMode) {&#10;            delay(300) // Pequeño delay para permitir la composición&#10;            try {&#10;                focusRequester.requestFocus()&#10;                keyboardController?.show()&#10;            } catch (e: Exception) {&#10;                // Maneja cualquier error de focus&#10;                keyboardController?.show()&#10;            }&#10;        } else {&#10;            keyboardController?.hide()&#10;        }&#10;    }&#10;&#10;    // --- Protección contra nota nula ---&#10;    // Guardamos la nota actual en una variable local para asegurar que no sea nula&#10;    // dentro del Scaffold, ya que la comprobación inicial ya se hizo.&#10;    val currentNote = note&#10;&#10;    if (currentNote == null) { // MODIFICADO: Usar la variable local&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Center) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    if (isEditMode) {&#10;                        Text(&quot;Editando nota&quot;)&#10;                    } else {&#10;                        Text(&#10;                            text = &quot;Hoy es $currentDate&quot;,&#10;                            style = MaterialTheme.typography.labelMedium.copy(&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, &quot;Volver&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // --- NUEVO: Botón Favorito ---&#10;                    IconButton(&#10;                        onClick = {&#10;                            // Llama a la función del ViewModel para cambiar el estado de favorito&#10;                            viewModel.toggleFavorite(currentNote.id)&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            // Cambia el icono según si la nota es favorita o no&#10;                            imageVector = if (currentNote.isFavorite) Icons.Filled.Favorite else Icons.Outlined.FavoriteBorder,&#10;                            contentDescription = if (currentNote.isFavorite) &quot;Quitar de favoritas&quot; else &quot;Marcar como favorita&quot;,&#10;                            // Opcional: Cambia el color si es favorita&#10;                            tint = if (currentNote.isFavorite) MaterialTheme.colorScheme.error else LocalContentColor.current // Puedes usar Color.Red o primary&#10;                        )&#10;                    }&#10;                    // --- FIN NUEVO ---&#10;&#10;                    // Botón de eliminar&#10;                    IconButton(&#10;                        onClick = { showDeleteDialog = true },&#10;                        // modifier = Modifier.padding(end = 8.dp) // Quitar padding si quieres que estén más juntos&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.Delete,&#10;                            contentDescription = &quot;Eliminar nota&quot;,&#10;                            tint = MaterialTheme.colorScheme.error&#10;                        )&#10;                    }&#10;&#10;                    // Botón de formato (solo en modo edición)&#10;                    if (isEditMode) {&#10;                        IconButton(&#10;                            onClick = {&#10;                                viewModel.updateCurrentNote { current -&gt;&#10;                                    current.copy(isMarkdownEnabled = !current.isMarkdownEnabled)&#10;                                }&#10;                            }&#10;                        ) {&#10;                            Icon(&#10;                                if (currentNote.isMarkdownEnabled) Icons.Default.Star else Icons.Default.Clear, // MODIFICADO: usar currentNote&#10;                                contentDescription = &quot;Formato Markdown&quot;,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Botón de edición/guardado&#10;                    IconButton(&#10;                        onClick = {&#10;                            if (isEditMode) {&#10;                                viewModel.saveCurrentNote() // Guarda la nota actual (incluyendo estado de favorito si cambió)&#10;                            }&#10;                            isEditMode = !isEditMode&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            if (isEditMode) Icons.Default.Check else Icons.Default.Edit,&#10;                            contentDescription = if (isEditMode) &quot;Guardar&quot; else &quot;Editar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            if (isEditMode) {&#10;                // MODO EDICIÓN&#10;                BasicTextField(&#10;                    value = currentNote.title, // MODIFICADO: usar currentNote&#10;                    onValueChange = { newTitle -&gt;&#10;                        viewModel.updateCurrentNote { it.copy(title = newTitle) }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    textStyle = MaterialTheme.typography.titleLarge.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    ),&#10;                    decorationBox = { innerTextField -&gt;&#10;                        Box {&#10;                            if (currentNote.title.isEmpty()) { // MODIFICADO: usar currentNote&#10;                                Text(&#10;                                    &quot;Título (opcional)&quot;,&#10;                                    style = MaterialTheme.typography.titleLarge.copy(&#10;                                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;                                )&#10;                            }&#10;                            innerTextField()&#10;                        }&#10;                    }&#10;                )&#10;&#10;                Divider(modifier = Modifier.padding(horizontal = 16.dp))&#10;&#10;                // Editor de contenido (Markdown o texto normal)&#10;                if (currentNote.isMarkdownEnabled) { // MODIFICADO: usar currentNote&#10;                    MarkdownEditor( // Asegúrate de que este Composable exista y funcione&#10;                        content = currentNote.content, // MODIFICADO: usar currentNote&#10;                        onContentChange = { newContent -&gt;&#10;                            viewModel.updateCurrentNote { it.copy(content = newContent) }&#10;                        }&#10;                    )&#10;                } else {&#10;                    BasicTextField(&#10;                        value = currentNote.content, // MODIFICADO: usar currentNote&#10;                        onValueChange = { newContent -&gt;&#10;                            viewModel.updateCurrentNote { it.copy(content = newContent) }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp)&#10;                            .focusRequester(focusRequester),&#10;                        textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                            fontSize = 18.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    )&#10;                }&#10;            } else {&#10;                // MODO LECTURA&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp)&#10;                        .verticalScroll(scrollState)&#10;                ) {&#10;                    // Ya no necesitamos el let porque usamos currentNote que sabemos no es null aquí&#10;                    if (currentNote.title.isNotEmpty() &amp;&amp; currentNote.title != &quot;Nota sin título&quot;) {&#10;                        Text(&#10;                            text = currentNote.title,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;&#10;                    if (currentNote.isMarkdownEnabled) {&#10;                        MarkdownText(&#10;                            markdown = currentNote.content,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    } else {&#10;                        Text(&#10;                            text = currentNote.content,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                lineHeight = 28.sp,&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                    // Pie de nota con metadatos&#10;                    Column(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.End&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Creada: ${dateFormatter.format(Date(currentNote.timestampInit))}&quot;,&#10;                            style = MaterialTheme.typography.labelSmall.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Modificada: ${dateFormatter.format(Date(currentNote.timestamp))}&quot;,&#10;                            style = MaterialTheme.typography.labelSmall.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                        if (currentNote.isMarkdownEnabled) {&#10;                            Text(&#10;                                text = &quot;Formato: Markdown&quot;,&#10;                                style = MaterialTheme.typography.labelSmall.copy(&#10;                                    color = MaterialTheme.colorScheme.primary.copy(alpha = 0.8f)&#10;                                )&#10;                            )&#10;                        }&#10;                        // NUEVO: Mostrar si es favorita en los metadatos&#10;                        if (currentNote.isFavorite) {&#10;                            Text(&#10;                                text = &quot;Favorita ⭐&quot;, // Puedes usar un emoji o texto&#10;                                style = MaterialTheme.typography.labelSmall.copy(&#10;                                    color = MaterialTheme.colorScheme.error.copy(alpha = 0.8f) // Usar un color distintivo&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Diálogo de confirmación&#10;            if (showDeleteDialog) {&#10;                AlertDialog(&#10;                    onDismissRequest = { showDeleteDialog = false },&#10;                    title = { Text(&quot;Eliminar nota&quot;) },&#10;                    text = { Text(&quot;¿Estás seguro de que quieres eliminar esta nota permanentemente?&quot;) },&#10;                    confirmButton = {&#10;                        TextButton(&#10;                            onClick = {&#10;                                // No necesitamos el let aquí porque currentNote no es null&#10;                                viewModel.deleteNote(currentNote)&#10;                                onBack() // Vuelve atrás después de eliminar&#10;                                showDeleteDialog = false&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Eliminar&quot;, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        TextButton(&#10;                            onClick = { showDeleteDialog = false }&#10;                        ) {&#10;                            Text(&quot;Cancelar&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Clear&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Done&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.Face&#10;// NUEVO: Importar iconos de corazón&#10;import androidx.compose.material.icons.filled.Favorite&#10;import androidx.compose.material.icons.outlined.FavoriteBorder&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Alignment.Companion.Center&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;// NUEVO: Importar Color si quieres un color específico como Rojo&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.res.painterResource&#10;import com.valdo.notasinteligentesvaldo.R&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import kotlinx.coroutines.delay&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class)&#10;@Composable&#10;fun NoteDetailScreen(&#10;    noteId: Int,&#10;    onBack: () -&gt; Unit,&#10;    viewModel: NoteViewModel = viewModel()&#10;) {&#10;    val note by viewModel.currentNote.collectAsState()&#10;    var isEditMode by remember { mutableStateOf(false) }&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    val focusRequester = remember { FocusRequester() }&#10;    val scrollState = rememberScrollState()&#10;    val currentDate = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM&quot;, Locale.getDefault()).format(Date())&#10;    }&#10;&#10;    // Formateador de fecha&#10;    val dateFormatter = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM 'a las' HH:mm&quot;, Locale.getDefault())&#10;    }&#10;&#10;    var showDeleteDialog by remember { mutableStateOf(false) }&#10;&#10;    // Carga inicial de la nota&#10;    LaunchedEffect(noteId) {&#10;        viewModel.loadNote(noteId)&#10;    }&#10;&#10;    // Manejo del teclado y foco - CORRECCIÓN IMPORTANTE&#10;    LaunchedEffect(isEditMode) {&#10;        if (isEditMode) {&#10;            delay(300) // Pequeño delay para permitir la composición&#10;            try {&#10;                focusRequester.requestFocus()&#10;                keyboardController?.show()&#10;            } catch (e: Exception) {&#10;                // Maneja cualquier error de focus&#10;                keyboardController?.show()&#10;            }&#10;        } else {&#10;            keyboardController?.hide()&#10;        }&#10;    }&#10;&#10;    // --- Protección contra nota nula ---&#10;    // Guardamos la nota actual en una variable local para asegurar que no sea nula&#10;    // dentro del Scaffold, ya que la comprobación inicial ya se hizo.&#10;    val currentNote = note&#10;&#10;    if (currentNote == null) { // MODIFICADO: Usar la variable local&#10;        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Center) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    if (isEditMode) {&#10;                        Text(&quot;Editando nota&quot;)&#10;                    } else {&#10;                        Text(&#10;                            text = &quot;Hoy es $currentDate&quot;,&#10;                            style = MaterialTheme.typography.labelMedium.copy(&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        )&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, &quot;Volver&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // --- NUEVO: Botón Favorito ---&#10;                    IconButton(&#10;                        onClick = {&#10;                            // Llama a la función del ViewModel para cambiar el estado de favorito&#10;                            viewModel.toggleFavorite(currentNote.id)&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            // Cambia el icono según si la nota es favorita o no&#10;                            imageVector = if (currentNote.isFavorite) Icons.Filled.Favorite else Icons.Outlined.FavoriteBorder,&#10;                            contentDescription = if (currentNote.isFavorite) &quot;Quitar de favoritas&quot; else &quot;Marcar como favorita&quot;,&#10;                            // Opcional: Cambia el color si es favorita&#10;                            tint = if (currentNote.isFavorite) MaterialTheme.colorScheme.error else LocalContentColor.current // Puedes usar Color.Red o primary&#10;                        )&#10;                    }&#10;                    // --- FIN NUEVO ---&#10;&#10;                    // Botón de eliminar&#10;                    IconButton(&#10;                        onClick = { showDeleteDialog = true },&#10;                        // modifier = Modifier.padding(end = 8.dp) // Quitar padding si quieres que estén más juntos&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.Delete,&#10;                            contentDescription = &quot;Eliminar nota&quot;,&#10;                            tint = MaterialTheme.colorScheme.error&#10;                        )&#10;                    }&#10;&#10;                    // Botón de formato (solo en modo edición)&#10;                    if (isEditMode) {&#10;                        IconButton(&#10;                            onClick = {&#10;                                viewModel.updateCurrentNote { current -&gt;&#10;                                    current.copy(isMarkdownEnabled = !current.isMarkdownEnabled)&#10;                                }&#10;                            }&#10;                        ) {&#10;                            val markdownIcon = if (currentNote.isMarkdownEnabled) R.drawable.code_off_24px else R.drawable.code_24px&#10;                            Icon(&#10;                                painter = painterResource(id = markdownIcon),&#10;                                contentDescription = &quot;Formato Markdown&quot;,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // Botón de edición/guardado&#10;                    IconButton(&#10;                        onClick = {&#10;                            if (isEditMode) {&#10;                                viewModel.saveCurrentNote() // Guarda la nota actual (incluyendo estado de favorito si cambió)&#10;                            }&#10;                            isEditMode = !isEditMode&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            if (isEditMode) Icons.Default.Check else Icons.Default.Edit,&#10;                            contentDescription = if (isEditMode) &quot;Guardar&quot; else &quot;Editar&quot;,&#10;                            tint = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            if (isEditMode) {&#10;                // MODO EDICIÓN&#10;                BasicTextField(&#10;                    value = currentNote.title, // MODIFICADO: usar currentNote&#10;                    onValueChange = { newTitle -&gt;&#10;                        viewModel.updateCurrentNote { it.copy(title = newTitle) }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(16.dp),&#10;                    textStyle = MaterialTheme.typography.titleLarge.copy(&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    ),&#10;                    decorationBox = { innerTextField -&gt;&#10;                        Box {&#10;                            if (currentNote.title.isEmpty()) { // MODIFICADO: usar currentNote&#10;                                Text(&#10;                                    &quot;Título (opcional)&quot;,&#10;                                    style = MaterialTheme.typography.titleLarge.copy(&#10;                                        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;                                )&#10;                            }&#10;                            innerTextField()&#10;                        }&#10;                    }&#10;                )&#10;&#10;                Divider(modifier = Modifier.padding(horizontal = 16.dp))&#10;&#10;                // Editor de contenido (Markdown o texto normal)&#10;                if (currentNote.isMarkdownEnabled) { // MODIFICADO: usar currentNote&#10;                    var preview by remember { mutableStateOf(false) }&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(8.dp),&#10;                        horizontalArrangement = Arrangement.End&#10;                    ) {&#10;                        IconButton(onClick = { preview = !preview }) {&#10;                            val previewIcon = if (preview) R.drawable.visibility_off_24px else R.drawable.visibility_24px&#10;                            Icon(&#10;                                painter = painterResource(id = previewIcon),&#10;                                contentDescription = &quot;Vista previa&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                    if (preview) {&#10;                        MarkdownText(&#10;                            markdown = currentNote.content,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    } else {&#10;                        BasicTextField(&#10;                            value = currentNote.content, // MODIFICADO: usar currentNote&#10;                            onValueChange = { newContent -&gt;&#10;                                viewModel.updateCurrentNote { it.copy(content = newContent) }&#10;                            },&#10;                            modifier = Modifier&#10;                                .fillMaxSize()&#10;                                .padding(16.dp)&#10;                                .focusRequester(focusRequester),&#10;                            textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontSize = 18.sp,&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    }&#10;                } else {&#10;                    BasicTextField(&#10;                        value = currentNote.content, // MODIFICADO: usar currentNote&#10;                        onValueChange = { newContent -&gt;&#10;                            viewModel.updateCurrentNote { it.copy(content = newContent) }&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp)&#10;                            .focusRequester(focusRequester),&#10;                        textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                            fontSize = 18.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    )&#10;                }&#10;            } else {&#10;                // MODO LECTURA&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp)&#10;                        .verticalScroll(scrollState)&#10;                ) {&#10;                    // Ya no necesitamos el let porque usamos currentNote que sabemos no es null aquí&#10;                    if (currentNote.title.isNotEmpty() &amp;&amp; currentNote.title != &quot;Nota sin título&quot;) {&#10;                        Text(&#10;                            text = currentNote.title,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;&#10;                    if (currentNote.isMarkdownEnabled) {&#10;                        MarkdownText(&#10;                            markdown = currentNote.content,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    } else {&#10;                        Text(&#10;                            text = currentNote.content,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                lineHeight = 28.sp,&#10;                                color = MaterialTheme.colorScheme.onSurface&#10;                            )&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                    // Pie de nota con metadatos&#10;                    Column(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.End&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Creada: ${dateFormatter.format(Date(currentNote.timestampInit))}&quot;,&#10;                            style = MaterialTheme.typography.labelSmall.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                        Text(&#10;                            text = &quot;Modificada: ${dateFormatter.format(Date(currentNote.timestamp))}&quot;,&#10;                            style = MaterialTheme.typography.labelSmall.copy(&#10;                                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                        if (currentNote.isMarkdownEnabled) {&#10;                            Text(&#10;                                text = &quot;Formato: Markdown&quot;,&#10;                                style = MaterialTheme.typography.labelSmall.copy(&#10;                                    color = MaterialTheme.colorScheme.primary.copy(alpha = 0.8f)&#10;                                )&#10;                            )&#10;                        }&#10;                        // NUEVO: Mostrar si es favorita en los metadatos&#10;                        if (currentNote.isFavorite) {&#10;                            Text(&#10;                                text = &quot;Favorita ⭐&quot;, // Puedes usar un emoji o texto&#10;                                style = MaterialTheme.typography.labelSmall.copy(&#10;                                    color = MaterialTheme.colorScheme.error.copy(alpha = 0.8f) // Usar un color distintivo&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Diálogo de confirmación&#10;            if (showDeleteDialog) {&#10;                AlertDialog(&#10;                    onDismissRequest = { showDeleteDialog = false },&#10;                    title = { Text(&quot;Eliminar nota&quot;) },&#10;                    text = { Text(&quot;¿Estás seguro de que quieres eliminar esta nota permanentemente?&quot;) },&#10;                    confirmButton = {&#10;                        TextButton(&#10;                            onClick = {&#10;                                // No necesitamos el let aquí porque currentNote no es null&#10;                                viewModel.deleteNote(currentNote)&#10;                                onBack() // Vuelve atrás después de eliminar&#10;                                showDeleteDialog = false&#10;                            }&#10;                        ) {&#10;                            Text(&quot;Eliminar&quot;, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        TextButton(&#10;                            onClick = { showDeleteDialog = false }&#10;                        ) {&#10;                            Text(&quot;Cancelar&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NoteFormScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NoteFormScreen.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Face&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.valdo.notasinteligentesvaldo.R&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class)&#10;@Composable&#10;fun NoteFormScreen(&#10;    onNoteSaved: (Note) -&gt; Unit,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var content by remember { mutableStateOf(&quot;&quot;) }&#10;    var isMarkdownEnabled by remember { mutableStateOf(false) }&#10;    val focusRequester = remember { FocusRequester() }&#10;    val currentDate = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM&quot;, Locale.getDefault()).format(Date())&#10;    }&#10;    val titleAlpha by animateFloatAsState(&#10;        targetValue = if (title.isBlank()) 0.5f else 1f,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, &quot;Volver&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Botón de toggle Markdown&#10;                    IconButton(&#10;                        onClick = { isMarkdownEnabled = !isMarkdownEnabled },&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    ) {&#10;                        val markdownIcon = if (isMarkdownEnabled) R.drawable.code_off_24px else R.drawable.code_24px&#10;                        Icon(&#10;                            painter = painterResource(id = markdownIcon),&#10;                            contentDescription = &quot;Markdown&quot;,&#10;                            tint = if (isMarkdownEnabled) MaterialTheme.colorScheme.primary&#10;                            else MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    // Botón de guardar&#10;                    IconButton(&#10;                        onClick = {&#10;                            val newNote = Note(&#10;                                title = title.ifEmpty { &quot;Nota sin título&quot; },&#10;                                content = content,&#10;                                timestamp = System.currentTimeMillis(),&#10;                                timestampInit = System.currentTimeMillis(),&#10;                                isMarkdownEnabled = isMarkdownEnabled&#10;                            )&#10;                            onNoteSaved(newNote)&#10;                            // Eliminado: onBack() aquí para evitar doble navegación&#10;                        },&#10;                        enabled = content.isNotBlank() || title.isNotBlank()&#10;                    ) {&#10;                        Icon(Icons.Default.Check, &quot;Guardar&quot;)&#10;                    }&#10;                },&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = currentDate,&#10;                            style = MaterialTheme.typography.labelMedium.copy(&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        )&#10;                        // Título siempre visible (pero transparente cuando está vacío)&#10;                        Text(&#10;                            text = title.ifEmpty { &quot; &quot; }, // Espacio para mantener altura&#10;                            style = MaterialTheme.typography.titleLarge.copy(&#10;                                color = if (title.isBlank()) Color.Transparent&#10;                                else MaterialTheme.colorScheme.onSurface,&#10;                                fontWeight = FontWeight.Bold,&#10;                                fontSize = 20.sp&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Campo de título&#10;            BasicTextField(&#10;                value = title,&#10;                onValueChange = { title = it },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                textStyle = MaterialTheme.typography.titleLarge.copy(&#10;                    color = MaterialTheme.colorScheme.onSurface,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 20.sp&#10;                ),&#10;                decorationBox = { innerTextField -&gt;&#10;                    Box {&#10;                        if (title.isEmpty()) {&#10;                            Text(&#10;                                text = title.ifEmpty { &quot;Añade un título...&quot; },&#10;                                style = MaterialTheme.typography.titleLarge.copy(&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = titleAlpha),&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    fontSize = 20.sp&#10;                                )&#10;                            )&#10;                        }&#10;                        innerTextField()&#10;                    }&#10;                }&#10;            )&#10;&#10;            Divider(modifier = Modifier.padding(horizontal = 16.dp))&#10;&#10;            // Área de contenido con soporte Markdown&#10;            if (isMarkdownEnabled) {&#10;                MarkdownEditor(content, onContentChange = { content = it })&#10;            } else {&#10;                BasicTextField(&#10;                    value = content,&#10;                    onValueChange = { content = it },&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp)&#10;                        .focusRequester(focusRequester),&#10;                    textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                        fontSize = 18.sp,&#10;                        lineHeight = 28.sp&#10;                    ),&#10;                    decorationBox = { innerTextField -&gt;&#10;                        if (content.isEmpty()) {&#10;                            Text(&#10;                                &quot;Comienza a escribir tu nota aquí...&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)&#10;                                )&#10;                            )&#10;                        }&#10;                        innerTextField()&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        LaunchedEffect(Unit) {&#10;            focusRequester.requestFocus()&#10;            keyboardController?.show()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MarkdownEditor(&#10;    content: String,&#10;    onContentChange: (String) -&gt; Unit&#10;) {&#10;    var preview by remember { mutableStateOf(false) }&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Barra de herramientas Markdown (corregida)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            IconButton(onClick = { onContentChange(&quot;$content **texto** &quot;) }) {&#10;                Text(&quot;B&quot;, fontWeight = FontWeight.Bold)&#10;            }&#10;            IconButton(onClick = { onContentChange(&quot;$content *texto* &quot;) }) {&#10;                Text(&quot;I&quot;, fontStyle = FontStyle.Italic)&#10;            }&#10;            IconButton(onClick = { onContentChange(&quot;$content [texto](url) &quot;) }) {&#10;                Text(&quot;Link&quot;)&#10;            }&#10;            IconButton(onClick = { preview = !preview }) {&#10;                val previewIcon = if (preview) R.drawable.visibility_off_24px else R.drawable.visibility_24px&#10;                Icon(&#10;                    painter = painterResource(id = previewIcon),&#10;                    contentDescription = &quot;Vista previa&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (preview) {&#10;            // Vista previa del Markdown&#10;            MarkdownPreview(content)&#10;        } else {&#10;            // Editor de Markdown&#10;            BasicTextField(&#10;                value = content,&#10;                onValueChange = onContentChange,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                textStyle = TextStyle(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MarkdownPreview(content: String) {&#10;    // Usamos una librería como compose-markdown para renderizar&#10;    MarkdownText(&#10;        markdown = content,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    )&#10;}" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.BasicTextField&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Check&#10;import androidx.compose.material.icons.filled.Face&#10;import androidx.compose.material.icons.filled.Star&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontStyle&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import dev.jeziellago.compose.markdowntext.MarkdownText&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import com.valdo.notasinteligentesvaldo.R&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class)&#10;@Composable&#10;fun NoteFormScreen(&#10;    onNoteSaved: (Note) -&gt; Unit,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    var title by remember { mutableStateOf(&quot;&quot;) }&#10;    var content by remember { mutableStateOf(&quot;&quot;) }&#10;    var isMarkdownEnabled by remember { mutableStateOf(false) }&#10;    val focusRequester = remember { FocusRequester() }&#10;    val currentDate = remember {&#10;        SimpleDateFormat(&quot;EEEE, d 'de' MMMM&quot;, Locale.getDefault()).format(Date())&#10;    }&#10;    val titleAlpha by animateFloatAsState(&#10;        targetValue = if (title.isBlank()) 0.5f else 1f,&#10;        animationSpec = tween(durationMillis = 300)&#10;    )&#10;&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, &quot;Volver&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    // Botón de toggle Markdown&#10;                    IconButton(&#10;                        onClick = { isMarkdownEnabled = !isMarkdownEnabled },&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    ) {&#10;                        val markdownIcon = if (isMarkdownEnabled) R.drawable.code_off_24px else R.drawable.code_24px&#10;                        Icon(&#10;                            painter = painterResource(id = markdownIcon),&#10;                            contentDescription = &quot;Markdown&quot;,&#10;                            tint = if (isMarkdownEnabled) MaterialTheme.colorScheme.primary&#10;                            else MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                    // Botón de guardar&#10;                    IconButton(&#10;                        onClick = {&#10;                            val newNote = Note(&#10;                                title = title.ifEmpty { &quot;Nota sin título&quot; },&#10;                                content = content,&#10;                                timestamp = System.currentTimeMillis(),&#10;                                timestampInit = System.currentTimeMillis(),&#10;                                isMarkdownEnabled = isMarkdownEnabled&#10;                            )&#10;                            onNoteSaved(newNote)&#10;                            // Eliminado: onBack() aquí para evitar doble navegación&#10;                        },&#10;                        enabled = content.isNotBlank() || title.isNotBlank()&#10;                    ) {&#10;                        Icon(Icons.Default.Check, &quot;Guardar&quot;)&#10;                    }&#10;                },&#10;                title = {&#10;                    Column {&#10;                        Text(&#10;                            text = currentDate,&#10;                            style = MaterialTheme.typography.labelMedium.copy(&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        )&#10;                        // Título siempre visible (pero transparente cuando está vacío)&#10;                        Text(&#10;                            text = title.ifEmpty { &quot; &quot; }, // Espacio para mantener altura&#10;                            style = MaterialTheme.typography.titleLarge.copy(&#10;                                color = if (title.isBlank()) Color.Transparent&#10;                                else MaterialTheme.colorScheme.onSurface,&#10;                                fontWeight = FontWeight.Bold,&#10;                                fontSize = 20.sp&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Campo de título&#10;            BasicTextField(&#10;                value = title,&#10;                onValueChange = { title = it },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 16.dp, vertical = 8.dp),&#10;                textStyle = MaterialTheme.typography.titleLarge.copy(&#10;                    color = MaterialTheme.colorScheme.onSurface,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 20.sp&#10;                ),&#10;                decorationBox = { innerTextField -&gt;&#10;                    Box {&#10;                        if (title.isEmpty()) {&#10;                            Text(&#10;                                text = title.ifEmpty { &quot;Añade un título...&quot; },&#10;                                style = MaterialTheme.typography.titleLarge.copy(&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = titleAlpha),&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    fontSize = 20.sp&#10;                                )&#10;                            )&#10;                        }&#10;                        innerTextField()&#10;                    }&#10;                }&#10;            )&#10;&#10;            Divider(modifier = Modifier.padding(horizontal = 16.dp))&#10;&#10;            // Área de contenido con soporte Markdown&#10;            if (isMarkdownEnabled) {&#10;                MarkdownEditor(content, onContentChange = { content = it })&#10;            } else {&#10;                BasicTextField(&#10;                    value = content,&#10;                    onValueChange = { content = it },&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp)&#10;                        .focusRequester(focusRequester),&#10;                    textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                        fontSize = 18.sp,&#10;                        lineHeight = 28.sp,&#10;                        color = MaterialTheme.colorScheme.onSurface // Color legible en modo oscuro&#10;                    ),&#10;                    decorationBox = { innerTextField -&gt;&#10;                        if (content.isEmpty()) {&#10;                            Text(&#10;                                &quot;Comienza a escribir tu nota aquí...&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f)&#10;                                )&#10;                            )&#10;                        }&#10;                        innerTextField()&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        LaunchedEffect(Unit) {&#10;            focusRequester.requestFocus()&#10;            keyboardController?.show()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MarkdownEditor(&#10;    content: String,&#10;    onContentChange: (String) -&gt; Unit&#10;) {&#10;    var preview by remember { mutableStateOf(false) }&#10;&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Barra de herramientas Markdown (corregida)&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            horizontalArrangement = Arrangement.SpaceEvenly&#10;        ) {&#10;            IconButton(onClick = { onContentChange(&quot;$content **texto** &quot;) }) {&#10;                Text(&quot;B&quot;, fontWeight = FontWeight.Bold)&#10;            }&#10;            IconButton(onClick = { onContentChange(&quot;$content *texto* &quot;) }) {&#10;                Text(&quot;I&quot;, fontStyle = FontStyle.Italic)&#10;            }&#10;            IconButton(onClick = { onContentChange(&quot;$content [texto](url) &quot;) }) {&#10;                Text(&quot;Link&quot;)&#10;            }&#10;            IconButton(onClick = { preview = !preview }) {&#10;                val previewIcon = if (preview) R.drawable.visibility_off_24px else R.drawable.visibility_24px&#10;                Icon(&#10;                    painter = painterResource(id = previewIcon),&#10;                    contentDescription = &quot;Vista previa&quot;&#10;                )&#10;            }&#10;        }&#10;&#10;        if (preview) {&#10;            // Vista previa del Markdown&#10;            MarkdownPreview(content)&#10;        } else {&#10;            // Editor de Markdown&#10;            BasicTextField(&#10;                value = content,&#10;                onValueChange = onContentChange,&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(16.dp),&#10;                textStyle = TextStyle(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MarkdownPreview(content: String) {&#10;    // Usamos una librería como compose-markdown para renderizar&#10;    MarkdownText(&#10;        markdown = content,&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NotesScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/valdo/notasinteligentesvaldo/screens/NotesScreen.kt" />
              <option name="originalContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import android.content.res.Configuration&#10;import androidx.compose.animation.Crossfade&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.* // Asegúrate que todos los imports necesarios estén&#10;import androidx.compose.foundation.lazy.staggeredgrid.LazyVerticalStaggeredGrid&#10;import androidx.compose.foundation.lazy.staggeredgrid.StaggeredGridCells&#10;import androidx.compose.foundation.lazy.staggeredgrid.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.* // Asegúrate que todos los iconos estén&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.* // Asegúrate que todos los imports de runtime estén&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.background&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel // Si no lo pasas como argumento&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.currentBackStackEntryAsState // Importar para obtener ruta actual&#10;import com.valdo.notasinteligentesvaldo.components.NoteCard&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.ui.res.painterResource&#10;import com.valdo.notasinteligentesvaldo.R&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NotesScreen(&#10;    viewModel: NoteViewModel,&#10;    navController: NavController,&#10;    filterType: String, // NUEVO: Parámetro para saber qué mostrar&#10;    onAddNote: () -&gt; Unit // Agregado parámetro para crear nueva nota&#10;) {&#10;    // Lógica para obtener las notas correctas según el filtro&#10;    // Usamos remember(filterType) para que el StateFlow correcto sea elegido cuando filterType cambie&#10;    val notesToDisplayState = remember(filterType) {&#10;        when (filterType) {&#10;            &quot;favorites&quot; -&gt; viewModel.favoriteNotes&#10;            else -&gt; viewModel.allNotes // &quot;all&quot; y cualquier otro caso muestran todas las notas&#10;        }&#10;    }.collectAsState() // Colecciona el Flow elegido&#10;&#10;    val notesToDisplay = notesToDisplayState.value // El valor actual de la lista a mostrar&#10;&#10;    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Cargar datos iniciales o cuando el filtro cambie&#10;    LaunchedEffect(filterType) {&#10;        when (filterType) {&#10;            &quot;favorites&quot; -&gt; viewModel.loadFavorites()&#10;            else -&gt; viewModel.loadAllNotes() // Carga todas por defecto&#10;        }&#10;    }&#10;&#10;    // Para saber qué item del drawer está seleccionado&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;    // Extraer el filtro de la ruta actual para la selección del drawer&#10;    val currentFilter = navBackStackEntry?.arguments?.getString(&quot;filterType&quot;) ?: &quot;all&quot;&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        drawerContent = {&#10;            ModalDrawerSheet {&#10;                Spacer(Modifier.height(16.dp))&#10;                // Item Inicio&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Inicio&quot;) },&#10;                    // Seleccionado si la ruta empieza con &quot;notes&quot; Y el filtro es &quot;all&quot;&#10;                    selected = currentRoute?.startsWith(&quot;notes&quot;) == true &amp;&amp; currentFilter == &quot;all&quot;,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        // Navega a la ruta 'notes' especificando el filtro 'all'&#10;                        navController.navigate(&quot;notes?filter=all&quot;) {&#10;                            popUpTo(navController.graph.startDestinationId) // Limpia stack hasta el inicio&#10;                            launchSingleTop = true // Evita duplicados de la pantalla de inicio&#10;                        }&#10;                        // No es necesario llamar a viewModel.loadAllNotes() aquí,&#10;                        // el LaunchedEffect se encargará al cambiar la ruta/filtro.&#10;                    },&#10;                    icon = { Icon(Icons.Default.Home, contentDescription = &quot;Inicio&quot;) }&#10;                )&#10;                // Item Favoritas&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Favoritas&quot;) },&#10;                    // Seleccionado si la ruta empieza con &quot;notes&quot; Y el filtro es &quot;favorites&quot;&#10;                    selected = currentRoute?.startsWith(&quot;notes&quot;) == true &amp;&amp; currentFilter == &quot;favorites&quot;,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        // Navega a la ruta 'notes' especificando el filtro 'favorites'&#10;                        navController.navigate(&quot;notes?filter=favorites&quot;) {&#10;                            launchSingleTop = true // Evita duplicados si ya estás en favoritas&#10;                            // Opcional: popUpTo como en Inicio si quieres limpiar el stack también&#10;                            // popUpTo(navController.graph.startDestinationId)&#10;                        }&#10;                        // No es necesario llamar a viewModel.loadFavorites() aquí,&#10;                        // el LaunchedEffect se encargará.&#10;                    },&#10;                    icon = { Icon(Icons.Default.Favorite, contentDescription = &quot;Favoritas&quot;) }&#10;                )&#10;                // Item Categorías (ejemplo, si lo implementas)&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Categorías&quot;) },&#10;                    selected = currentRoute == &quot;categories&quot;, // Asumiendo una ruta &quot;categories&quot; separada&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        // navController.navigate(&quot;categories&quot;) // Navegar a la ruta de categorías&#10;                    },&#10;                    icon = { Icon(Icons.Default.Menu, contentDescription = &quot;Categorías&quot;) } // Cambiar icono si es necesario&#10;                )&#10;                HorizontalDivider() // Usar HorizontalDivider de Material 3&#10;                // Item Ajustes&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Ajustes&quot;) },&#10;                    selected = currentRoute == &quot;settings&quot;, // Asumiendo una ruta &quot;settings&quot; separada&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        // navController.navigate(&quot;settings&quot;) // Navegar a la ruta de ajustes&#10;                    },&#10;                    icon = { Icon(Icons.Default.Settings, contentDescription = &quot;Ajustes&quot;) }&#10;                )&#10;            }&#10;        }&#10;    ) {&#10;        Scaffold(&#10;            floatingActionButton = {&#10;                FloatingActionButton(&#10;                    onClick = { navController.navigate(&quot;addNote&quot;) }, // Navega a la pantalla de añadir nota&#10;                    modifier = Modifier.defaultMinSize(minWidth = 150.dp, minHeight = 56.dp),&#10;                    containerColor = MaterialTheme.colorScheme.primary // Color del FAB&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(horizontal = 16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Nueva nota :)&quot;,&#10;                            style = MaterialTheme.typography.labelLarge, // Usar labelLarge para FAB texto&#10;                            color = MaterialTheme.colorScheme.onPrimary // Color del texto sobre el FAB&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            topBar = {&#10;                TopAppBar(&#10;                    // MODIFICADO: Título cambia según el filtro&#10;                    title = { Text(if (filterType == &quot;favorites&quot;) &quot;Notas Favoritas&quot; else &quot;Mis Notas&quot;) },&#10;                    navigationIcon = {&#10;                        IconButton(&#10;                            onClick = { scope.launch { drawerState.open() } }&#10;                        ) {&#10;                            Icon(Icons.Default.Menu, contentDescription = &quot;Abrir menú&quot;)&#10;                        }&#10;                    },&#10;                    actions = {&#10;                        IconButton(&#10;                            onClick = {&#10;                                // MODIFICADO: Refrescar según el filtro actual&#10;                                when (filterType) {&#10;                                    &quot;favorites&quot; -&gt; viewModel.loadFavorites()&#10;                                    else -&gt; viewModel.loadAllNotes()&#10;                                }&#10;                            }&#10;                        ) {&#10;                            Icon(Icons.Default.Refresh, contentDescription = &quot;Refrescar&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        ) { padding -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .padding(padding)&#10;                    .background(MaterialTheme.colorScheme.background) // Fondo consistente con el tema&#10;            ) {&#10;                // Usa Crossfade para animar el cambio entre la lista vacía y la llena&#10;                Crossfade(&#10;                    targetState = notesToDisplay.isEmpty(),&#10;                    label = &quot;NotesGridCrossfade&quot;,&#10;                    animationSpec = tween(durationMillis = 300)&#10;                ) { isEmpty -&gt;&#10;                    if (isEmpty) {&#10;                        val emptyMessage = when(filterType) {&#10;                            &quot;favorites&quot; -&gt; &quot;Aún no tienes notas favoritas.&quot;&#10;                            else -&gt; &quot;¡Crea tu primera nota!&quot;&#10;                        }&#10;                        EmptyNotesMessage(&#10;                            message = emptyMessage,&#10;                            onAddNoteClick = onAddNote,&#10;                            isFavorites = filterType == &quot;favorites&quot;&#10;                        )&#10;                    } else {&#10;                        // El estado cuando la lista NO está vacía&#10;                        NotesGrid(&#10;                            notes = notesToDisplay,&#10;                            onNoteClick = { note -&gt; navController.navigate(&quot;noteDetail/${note.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// MODIFICADO: EmptyNotesMessage para aceptar un mensaje y callback de click&#10;@Composable&#10;private fun EmptyNotesMessage(message: String, onAddNoteClick: () -&gt; Unit, isFavorites: Boolean = false) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;            val iconRes = if (isFavorites) R.drawable.sentiment_sad_24px else R.drawable.add_notes_24px&#10;            Icon(&#10;                painter = painterResource(id = iconRes),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .clickable { if (!isFavorites) onAddNoteClick() }, // Solo clickeable si no es favoritos&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Spacer(Modifier.height(16.dp))&#10;            Text(&#10;                text = message,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NotesGrid(notes: List&lt;Note&gt;, onNoteClick: (Note) -&gt; Unit) {&#10;    val configuration = LocalConfiguration.current&#10;    val columns = if (configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) 3 else 2&#10;&#10;    LazyVerticalStaggeredGrid(&#10;        columns = StaggeredGridCells.Fixed(columns),&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentPadding = PaddingValues(8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;        verticalItemSpacing = 8.dp&#10;    ) {&#10;        items(notes, key = { it.id }) { note -&gt;&#10;            NoteCard(note = note, onNoteClick = onNoteClick) // Asegúrate que NoteCard esté bien definido&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.valdo.notasinteligentesvaldo.screens&#10;&#10;import android.content.res.Configuration&#10;import androidx.compose.animation.Crossfade&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.ExperimentalFoundationApi&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.* // Asegúrate que todos los imports necesarios estén&#10;import androidx.compose.foundation.lazy.staggeredgrid.LazyVerticalStaggeredGrid&#10;import androidx.compose.foundation.lazy.staggeredgrid.StaggeredGridCells&#10;import androidx.compose.foundation.lazy.staggeredgrid.items&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.* // Asegúrate que todos los iconos estén&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.* // Asegúrate que todos los imports de runtime estén&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.background&#10;import androidx.compose.ui.draw.background&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel // Si no lo pasas como argumento&#10;import androidx.navigation.NavController&#10;import androidx.navigation.compose.currentBackStackEntryAsState // Importar para obtener ruta actual&#10;import com.valdo.notasinteligentesvaldo.components.NoteCard&#10;import com.valdo.notasinteligentesvaldo.models.Note&#10;import com.valdo.notasinteligentesvaldo.viewmodel.NoteViewModel&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.ui.res.painterResource&#10;import com.valdo.notasinteligentesvaldo.R&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NotesScreen(&#10;    viewModel: NoteViewModel,&#10;    navController: NavController,&#10;    filterType: String, // NUEVO: Parámetro para saber qué mostrar&#10;    onAddNote: () -&gt; Unit // Agregado parámetro para crear nueva nota&#10;) {&#10;    // Lógica para obtener las notas correctas según el filtro&#10;    // Usamos remember(filterType) para que el StateFlow correcto sea elegido cuando filterType cambie&#10;    val notesToDisplayState = remember(filterType) {&#10;        when (filterType) {&#10;            &quot;favorites&quot; -&gt; viewModel.favoriteNotes&#10;            else -&gt; viewModel.allNotes // &quot;all&quot; y cualquier otro caso muestran todas las notas&#10;        }&#10;    }.collectAsState() // Colecciona el Flow elegido&#10;&#10;    val notesToDisplay = notesToDisplayState.value // El valor actual de la lista a mostrar&#10;&#10;    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Cargar datos iniciales o cuando el filtro cambie&#10;    LaunchedEffect(filterType) {&#10;        when (filterType) {&#10;            &quot;favorites&quot; -&gt; viewModel.loadFavorites()&#10;            else -&gt; viewModel.loadAllNotes() // Carga todas por defecto&#10;        }&#10;    }&#10;&#10;    // Para saber qué item del drawer está seleccionado&#10;    val navBackStackEntry by navController.currentBackStackEntryAsState()&#10;    val currentRoute = navBackStackEntry?.destination?.route&#10;    // Extraer el filtro de la ruta actual para la selección del drawer&#10;    val currentFilter = navBackStackEntry?.arguments?.getString(&quot;filterType&quot;) ?: &quot;all&quot;&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        drawerContent = {&#10;            ModalDrawerSheet {&#10;                Spacer(Modifier.height(16.dp))&#10;                // Item Inicio&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Inicio&quot;) },&#10;                    // Seleccionado si la ruta empieza con &quot;notes&quot; Y el filtro es &quot;all&quot;&#10;                    selected = currentRoute?.startsWith(&quot;notes&quot;) == true &amp;&amp; currentFilter == &quot;all&quot;,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        // Navega a la ruta 'notes' especificando el filtro 'all'&#10;                        navController.navigate(&quot;notes?filter=all&quot;) {&#10;                            popUpTo(navController.graph.startDestinationId) // Limpia stack hasta el inicio&#10;                            launchSingleTop = true // Evita duplicados de la pantalla de inicio&#10;                        }&#10;                        // No es necesario llamar a viewModel.loadAllNotes() aquí,&#10;                        // el LaunchedEffect se encargará al cambiar la ruta/filtro.&#10;                    },&#10;                    icon = { Icon(Icons.Default.Home, contentDescription = &quot;Inicio&quot;) }&#10;                )&#10;                // Item Favoritas&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Favoritas&quot;) },&#10;                    // Seleccionado si la ruta empieza con &quot;notes&quot; Y el filtro es &quot;favorites&quot;&#10;                    selected = currentRoute?.startsWith(&quot;notes&quot;) == true &amp;&amp; currentFilter == &quot;favorites&quot;,&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        // Navega a la ruta 'notes' especificando el filtro 'favorites'&#10;                        navController.navigate(&quot;notes?filter=favorites&quot;) {&#10;                            launchSingleTop = true // Evita duplicados si ya estás en favoritas&#10;                            // Opcional: popUpTo como en Inicio si quieres limpiar el stack también&#10;                            // popUpTo(navController.graph.startDestinationId)&#10;                        }&#10;                        // No es necesario llamar a viewModel.loadFavorites() aquí,&#10;                        // el LaunchedEffect se encargará.&#10;                    },&#10;                    icon = { Icon(Icons.Default.Favorite, contentDescription = &quot;Favoritas&quot;) }&#10;                )&#10;                // Item Categorías (ejemplo, si lo implementas)&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Categorías&quot;) },&#10;                    selected = currentRoute == &quot;categories&quot;, // Asumiendo una ruta &quot;categories&quot; separada&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        // navController.navigate(&quot;categories&quot;) // Navegar a la ruta de categorías&#10;                    },&#10;                    icon = { Icon(Icons.Default.Menu, contentDescription = &quot;Categorías&quot;) } // Cambiar icono si es necesario&#10;                )&#10;                HorizontalDivider() // Usar HorizontalDivider de Material 3&#10;                // Item Ajustes&#10;                NavigationDrawerItem(&#10;                    label = { Text(&quot;Ajustes&quot;) },&#10;                    selected = currentRoute == &quot;settings&quot;, // Asumiendo una ruta &quot;settings&quot; separada&#10;                    onClick = {&#10;                        scope.launch { drawerState.close() }&#10;                        // navController.navigate(&quot;settings&quot;) // Navegar a la ruta de ajustes&#10;                    },&#10;                    icon = { Icon(Icons.Default.Settings, contentDescription = &quot;Ajustes&quot;) }&#10;                )&#10;            }&#10;        }&#10;    ) {&#10;        Scaffold(&#10;            floatingActionButton = {&#10;                FloatingActionButton(&#10;                    onClick = { navController.navigate(&quot;addNote&quot;) }, // Navega a la pantalla de añadir nota&#10;                    modifier = Modifier.defaultMinSize(minWidth = 150.dp, minHeight = 56.dp),&#10;                    containerColor = MaterialTheme.colorScheme.primary // Color del FAB&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.padding(horizontal = 16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Nueva nota :)&quot;,&#10;                            style = MaterialTheme.typography.labelLarge, // Usar labelLarge para FAB texto&#10;                            color = MaterialTheme.colorScheme.onPrimary // Color del texto sobre el FAB&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            topBar = {&#10;                TopAppBar(&#10;                    // MODIFICADO: Título cambia según el filtro&#10;                    title = { Text(if (filterType == &quot;favorites&quot;) &quot;Notas Favoritas&quot; else &quot;Mis Notas&quot;) },&#10;                    navigationIcon = {&#10;                        IconButton(&#10;                            onClick = { scope.launch { drawerState.open() } }&#10;                        ) {&#10;                            Icon(Icons.Default.Menu, contentDescription = &quot;Abrir menú&quot;)&#10;                        }&#10;                    },&#10;                    actions = {&#10;                        IconButton(&#10;                            onClick = {&#10;                                // MODIFICADO: Refrescar según el filtro actual&#10;                                when (filterType) {&#10;                                    &quot;favorites&quot; -&gt; viewModel.loadFavorites()&#10;                                    else -&gt; viewModel.loadAllNotes()&#10;                                }&#10;                            }&#10;                        ) {&#10;                            Icon(Icons.Default.Refresh, contentDescription = &quot;Refrescar&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        ) { padding -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .padding(padding)&#10;                    .background(MaterialTheme.colorScheme.background) // Fondo consistente con el tema&#10;            ) {&#10;                // Usa Crossfade para animar el cambio entre la lista vacía y la llena&#10;                Crossfade(&#10;                    targetState = notesToDisplay.isEmpty(),&#10;                    label = &quot;NotesGridCrossfade&quot;,&#10;                    animationSpec = tween(durationMillis = 300)&#10;                ) { isEmpty -&gt;&#10;                    if (isEmpty) {&#10;                        val emptyMessage = when(filterType) {&#10;                            &quot;favorites&quot; -&gt; &quot;Aún no tienes notas favoritas.&quot;&#10;                            else -&gt; &quot;¡Crea tu primera nota!&quot;&#10;                        }&#10;                        EmptyNotesMessage(&#10;                            message = emptyMessage,&#10;                            onAddNoteClick = onAddNote,&#10;                            isFavorites = filterType == &quot;favorites&quot;&#10;                        )&#10;                    } else {&#10;                        // El estado cuando la lista NO está vacía&#10;                        NotesGrid(&#10;                            notes = notesToDisplay,&#10;                            onNoteClick = { note -&gt; navController.navigate(&quot;noteDetail/${note.id}&quot;) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// MODIFICADO: EmptyNotesMessage para aceptar un mensaje y callback de click&#10;@Composable&#10;private fun EmptyNotesMessage(message: String, onAddNoteClick: () -&gt; Unit, isFavorites: Boolean = false) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;            val iconRes = if (isFavorites) R.drawable.sentiment_sad_24px else R.drawable.add_notes_24px&#10;            Icon(&#10;                painter = painterResource(id = iconRes),&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .clickable { if (!isFavorites) onAddNoteClick() }, // Solo clickeable si no es favoritos&#10;                tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Spacer(Modifier.height(16.dp))&#10;            Text(&#10;                text = message,&#10;                style = MaterialTheme.typography.bodyLarge,&#10;                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@OptIn(ExperimentalFoundationApi::class)&#10;@Composable&#10;fun NotesGrid(notes: List&lt;Note&gt;, onNoteClick: (Note) -&gt; Unit) {&#10;    val configuration = LocalConfiguration.current&#10;    val columns = if (configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) 3 else 2&#10;&#10;    LazyVerticalStaggeredGrid(&#10;        columns = StaggeredGridCells.Fixed(columns),&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentPadding = PaddingValues(8.dp),&#10;        horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;        verticalItemSpacing = 8.dp&#10;    ) {&#10;        items(notes, key = { it.id }) { note -&gt;&#10;            NoteCard(note = note, onNoteClick = onNoteClick) // Asegúrate que NoteCard esté bien definido&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>